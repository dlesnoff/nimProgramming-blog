<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>macroTutorial_fr.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="nimib 0.3.10" name="generator">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/light.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/atom-one-light.css'>
    <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
pre > code {
  font-size: 1.2em;
}
.nb-output {
  line-height: 1.15;
}
figure {
  margin: 2rem 0;
}
figcaption {
  text-align: center;
}
  
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href=".">üè°</a></span>
  <span><code>macroTutorial_fr.nim</code></span>
  <span><a href="https://github.com/dlesnoff/nimMacros.github.io"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle;" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59c.4.07.55-.17.55-.38c0-.19-.01-.82-.01-1.49c-2.01.37-2.53-.49-2.69-.94c-.09-.23-.48-.94-.82-1.13c-.28-.15-.68-.52-.01-.53c.63-.01 1.08.58 1.23.82c.72 1.21 1.87.87 2.33.66c.07-.52.28-.87.51-1.07c-1.78-.2-3.64-.89-3.64-3.95c0-.87.31-1.59.82-2.15c-.08-.2-.36-1.02.08-2.12c0 0 .67-.21 2.2.82c.64-.18 1.32-.27 2-.27c.68 0 1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82c.44 1.1.16 1.92.08 2.12c.51.56.82 1.27.82 2.15c0 3.07-1.87 3.75-3.65 3.95c.29.25.54.73.54 1.48c0 1.07-.01 1.93-.01 2.2c0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill="#000"></path></svg></a></span>
</div>
<hr>
</header><main>
<h1 style="text-align: center;">Les macros avec Nim - tutoriel de m√©taprogrammation</h1>
<p>Ce tutoriel a pour objectif d'√™tre une introduction aux capacit√©s de m√©taprogrammation du langage de programmation Nim. Il vise √† donner autant de d√©tails que possible pour d√©marrer vos projets les plus fous.
Il existe de nombreuses ressources que ce soit √† travers les livres ou sur Internet mais vous devriez trouvez ici (√† terme) une description compl√®te du processus de d√©veloppement de macros.</p>
<h3>Plan:</h3>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#proc√©dures-g√©n√©riques">Proc√©dures G√©n√©riques</a></li>
<li><a href="#templates">Templates</a></li>
<li><a href="#macros">Macros</a></li>
<li><a href="#references-and-bibliography">References and Bibliography</a></li>
</ol>
<p><a name = "introduction"></a></p>
<h2>Introduction</h2>
<hr />
<blockquote>
<p>Qu'est-ce que la m√©taprogrammation ?</p>
</blockquote>
<p>La m√©taprogrammation consiste √† programmer du code informatique. Autrement dit, l'entr√©e et la sortie de programmes r√©alisant de la m√©taprogrammation seront eux-m√™mes des bouts de code.</p>
<blockquote>
<p>Mon language pr√©f√©r√© ne me permet pas d'√©crire des macros. Pourquoi √©crire des macros (avec Nim)?</p>
</blockquote>
<p>Le principal objectif est d'√©crire facilement des longues portions de code qui sont r√©p√©titives ou pour s'adapter par exemple √† de nombreuses architectures.
Il est √©galement possible d'√©crire de mini-langages de programmation nomm√©s DSL (&quot;domain-specific languages&quot;) pour une utilisation pr√©cise, comme la description de contenu d'une fen√™tre graphique avec <code>Owlkettle</code>
ou pour sp√©cifier les param√®tres d'un r√©seau de neurones <code>Arraymancer</code>. Les macros sont √©crites une fois par le d√©veloppeur d'une biblioth√®que, et les utilisateurs de cette biblioth√®que vont voir leur code modifi√©
par les macros sans m√™me utiliser de macros par eux-m√™mes.</p>
<blockquote>
<p>Quel rapport avec les macros ?</p>
</blockquote>
<p>Les macros sont ces fonctions qui vont travailler sur des bouts de code et g√©n√©rer du code en sortie. Nous verrons par la suite que ce code est repr√©sent√©
sous la forme d'arbre syntaxique nomm√© AST.</p>
<h3>Quatre niveaux d'abstraction</h3>
<p>Il existe quatre niveaux d'abstraction en m√©taprogrammation qui sont chacun associ√©s √† un type de proc√©dure ou it√©rateur:</p>
<ol start="0">
<li>Proc√©dures/fonctions/it√©rateurs ordinaires (Pas de m√©taprogrammation)</li>
<li>Les proc√©dures g√©n√©riques et les classes de type (M√©taprogrammation au niveau du type)</li>
<li>Les ¬´ mod√®les ¬ª <code>template</code> en anglais (Un m√©chanisme de copier-coller avanc√©)</li>
<li>Les <code>Macro</code>s (Substitution d'arbre syntaxique <code>AST</code>)</li>
</ol>
<p>Il faut garder en t√™te que la m√©taprogrammation est un m√©chanisme complexe, et il est fortement recommand√© d'utiliser le niveau d'abstraction le plus faible possible,
et pas de m√©taprogrammation du tout lorsque cela est possible. Il existe plusieurs raisons √† cela. Premi√®rement, il est difficile de relire du code source utilisant de la
m√©taprogrammation. Cela demande beaucoup de temps pour v√©rifier que le code source ne g√©n√®re pas d'erreur et trouver l'origine d'une erreur s'il y en a une.
Sans commentaire, une macro est presque illisible. Vous verrez par la suite qu'il est difficile de comprendre l'objectif et le fonctionnement d'une macro rien qu'en la lisant.
Deuxi√®mement, il est difficile de faire de la gestion d'exception lorsqu'on manipule du code source. Il faut v√©rifier le code source qu'on re√ßoit en entr√©e d'une macro, et comme
les possibilit√©s sont tr√®s nombreuses, il est presque impossible de trier des codes sources valides en entr√©e d'une macro. Cela pose des probl√©matiques de s√©curit√© √©videntes. C'est une des raisons
pour laquelle la plupart des langages de programmation ont √©vit√© d'introduire des capacit√©s de m√©taprogrammation. Enfin, les temps de compilation sont proportionnels au travail que doit r√©aliser le
compilateur. Plus le niveau de m√©taprogrammation est avanc√©, plus le temps de compilation augmente, rendant le d√©veloppement plus complexe et for√ßant ainsi la fragmentation du code en plusieurs modules.</p>
<p>Je vous propose dans ce tutoriel une pr√©sentation de ces quatre niveaux de m√©taprogrammation. Nous verrons au passage des notions n√©cessaires au d√©veloppement de macros, comme les param√®tres non typ√©s,
l'hygi√©nisation des variables, l'introspection de code, les arbres syntaxiques. En bonus, nous verrons des bouts de code (¬´ snippets ¬ª en anglais) qui vous seront peut-√™tre utiles en dehors de la m√©taprogrammation.
Avant d'aborder les macros et les arbres syntaxiques, nous commen√ßons donc avec les proc√©dures g√©n√©riques, puis les mod√®les avec les param√®tres non typ√©s.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/macros</code></pre>
<p><a name = "proc√©dures-g√©n√©riques"></a></p>
<h2>Proc√©dures G√©n√©riques</h2>
<hr />
<p>Un des objectifs de la programmation est l'automatisation de t√¢ches r√©p√©titives.
Certains programmes sont fastidieux √† √©crire et nous √©crivons souvent des codes similaires.</p>
<p>Imaginez que vous voulez programmer une addition. Votre algorithme est probablement g√©n√©ral et ne d√©pend peut-√™tre pas du type de l'entr√©e. Votre algorithme pourrait recevoir
aussi bien des entiers que des nombres flottants en entr√©e.</p>
<p>Vous ne voulez pas r√©√©crire chacun de vos algorithmes pour chacun des types qui conviendraient.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># What to not do!</span>
<span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =
  <span class="hljs-keyword">return</span> x + y

<span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">float</span>): <span class="hljs-built_in">float</span> =
  <span class="hljs-keyword">return</span> x + y

<span class="hljs-keyword">echo</span> add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">echo</span> add(<span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span>)</code></pre><pre class="nb-output">5
8.199999999999999</pre>
<p>En effet, que se passerait-il si vous vouliez ajouter une fonction pour un autre type comme <code>int32</code> ou <code>float16</code>?
Vous devrez alors copier-coller votre fonction et changer le type. Bien que cela semble anodin, cela se r√©v√®le vite probl√©matique lorsque vous trouvez un bug dans l'algorithme.</p>
<p>Il vous faut alors corriger autant de fonctions que de types support√©s. De plus, le code devient peu lisible, puisque chaque fonction appara√Æt de nombreuses fois.</p>
<p>Une premi√®re solution consiste √† utiliser les types ¬´ g√©n√©riques implicites ¬ª. On utilise le mot-cl√© <code>or</code> comme pour une expression bool√©enne avec les types qui conviendraient.
Durant la phase de compilation, le compilateur Nim choisit quel type convient √† la situation.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> add(x,y: (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>)): (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>) =
  <span class="hljs-keyword">return</span> x + y

add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span></code></pre>
<p>Il se peut que vous ne sachiez pas vraiment √† l'avance combien de types exactement pourrait √™tre utilis√©s pour votre algorithme.
Vous voudriez peut-√™tre faire des modifications pour certains types pr√©cis. Il convient alors d'utiliser un type g√©n√©rique (non implicite).
Il s'agit d'un type repr√©sent√© par une variable. Par convention, on d√©signe cette variable par une lettre majuscule qui est souvent T, U, V, etc ‚Ä¶</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> add[<span class="hljs-type">T</span>](x,y: <span class="hljs-type">T</span>): <span class="hljs-type">T</span> =
  <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
    x = x.parseFloat()
    y = y.parseFloat()
  <span class="hljs-keyword">var</span> c = x + y
  <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
    <span class="hljs-keyword">return</span> $c
  <span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">return</span> c

add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span>
add <span class="hljs-string">&quot;3.7&quot;</span>, <span class="hljs-string">&quot;4.5&quot;</span></code></pre>
<p><a name = "templates"></a></p>
<h2>Templates</h2>
<hr />
<p>‚ö†Ô∏è Afin d'ex√©cuter chaque code dans la suite de ce tutoriel, vous devrez importer le paquet <code>std/macros</code>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/macros</code></pre>
<p>Nous pouvons voir les <em>templates</em> comme des proc√©dures qui font de la substitution de code, comme un couper-coller qui serait r√©alis√© √† la compilation.</p>
<p>Les proc√©dures <code>templates</code> re√ßoivent g√©n√©ralement en dernier param√®tre un bout de code.
Le type qui correspond √† un bout de code est <code>untyped</code>.
Comme nous souhaitons que le template retourne un bout de code, le type de retour est <code>untyped</code> pour presque tous les cas d'usage.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">not</span> (a == b)</code></pre>
<p>:warning: Le reste du tutoriel n'a pas encore √©t√© traduit de l'anglais vers le fran√ßais.</p>
<p>The Nim language defines boolean operators like <code>!=</code> with templates. You can even look at Nim's source code, that's almost the same code. See the <a href="https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped">documentation</a>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">## Example from std/manual</span>
<span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">not</span> (a == b)

doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>)</code></pre>
<p>We can easily repeat code under a custom block. Here duplicate, just duplicate code and repeat takes an additional parameter, an int, as a generalisation of the <code>duplicate</code> template.
Notice that duplicate is not smart. It will repeat any assignment twice in the code's block.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
  statements
  statements

duplicate:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span></code></pre><pre class="nb-output">5
5</pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">## Example from Nim In Action</span>
<span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep
<span class="hljs-keyword">template</span> repeat(count: <span class="hljs-built_in">int</span>, statements: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; count:
    statements

repeat <span class="hljs-number">5</span>:
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Hello Templates!&quot;</span>)
  sleep(<span class="hljs-number">100</span>)</code></pre><pre class="nb-output">Hello Templates!
Hello Templates!
Hello Templates!
Hello Templates!
Hello Templates!</pre>
<h4>Do-While keyword</h4>
<p>In Nim, there are few restricted keywords and special control-flow mechanisms, as to incite us to create our own constructs (and keep the language simple). Nothing restrains us from defining a <code>doWhile</code> construct similar to languages like <code>C</code> or <code>Javascript</code>.</p>
<p>For those only knowing Nim, this construct enables to run a loop once before testing the condition.</p>
<p>This C code always print <code>Hello World</code> at least once independantly from the start value of the variable <code>i</code>.</p>
<pre><code class="language-cpp">int i = 10;
do{
  printf(&quot;Hello World&quot;);
  i += 1;
}while(i &lt; 10);
</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
  loop
  <span class="hljs-keyword">while</span> conditional:
    loop

<span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>
doWhile i &lt; <span class="hljs-number">10</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span>
    i.inc</code></pre><pre class="nb-output">Hello World</pre>
<p>Notice though that <em>syntaxically</em> the resulting source code is fairly different than the C++ code.</p>
<p>In the C source code, appear in this order:</p>
<ol>
<li>the <code>do</code> keyword</li>
<li>the block of instruction</li>
<li>the <code>while</code> keyword</li>
<li>the conditional (boolean expression)</li>
</ol>
<p>In Nim, we have in this order:</p>
<ol>
<li>the <code>doWhile</code> indent</li>
<li>the conditional</li>
<li>block of instruction</li>
</ol>
<p>There is no way to modify Nim's syntax as to match C's syntax.</p>
<h4>Benchmark example</h4>
<p>Another example is benchmarking code in Nim. It suffices to put our bench code inside a special block.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/[times, monotimes]
<span class="hljs-keyword">template</span> benchmark(benchmarkName: <span class="hljs-built_in">string</span>, code: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">block</span>:
    <span class="hljs-keyword">let</span> t0 = getMonoTime()
    code
    <span class="hljs-keyword">let</span> elapsed = getMonoTime() - t0
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, benchmarkName, <span class="hljs-string">&quot;] &quot;</span>, elapsed

benchmark <span class="hljs-string">&quot;test1&quot;</span>:
  sleep(<span class="hljs-number">100</span>)</code></pre><pre class="nb-output">CPU Time [test1] 100 milliseconds, 208 microseconds, and 351 nanoseconds</pre>
<p>The code inside the <code>benchmark</code> code block will be enclosed by our template code.</p>
<p>Since the code replacement is done at compile time, this transformation does not add additional runtime to our benchmarked code.
On the contrary, a function or procedure for benchmarking would have add runtime due to the nested function calls.</p>
<p><a name = "macros"></a></p>
<h2>Macros</h2>
<hr />
<p>Template uses <code>untyped</code> parameters as lego bricks. It can not break it down into smaller pieces.
We can not check untyped parameters in a template. If our template works when given an object as argument, nothing restrics an user to give a function as argument.</p>
<p>Macros can be seen as an empowered template procedure. While template substitute code, macros do introspection.
The main difference is that a template can not look inside an untyped parameter. This means that we can not check the input we get as to verify that the user did not give a function when we expect a type.</p>
<p>One can parse untyped parameters with macros. We can even act something conditionally to informations given in these parameters.
We can also inject variables into scopes.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> throwAway(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-literal">result</span> = newStmtList()

throwAway:
  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;If you do not throw me, I'll spam you indefinitely!&quot;</span></code></pre>
<h3>AST Manipulation</h3>
<p>In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST). To get a representation of the AST corresponding to a code, we can use the <code>macro</code> <code>dumpTree</code>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># Don't forget to import std/macros!</span>
<span class="hljs-comment"># You can use --hints:off to display only the AST tree</span>
dumpTree:
  <span class="hljs-keyword">type</span>
    myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      left: <span class="hljs-built_in">seq</span>[myObject]
      right: <span class="hljs-built_in">seq</span>[myObject]</code></pre>
<p>This code outputs the following AST tree (it should not change among Nim versions).</p>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
</code></pre>
<p>We can better visualize the tree structure of the AST with the following picture.</p>
<figure>
<img src="./ASTtree.jpg" alt="Nim's Abstract Syntax Tree visualized with a tree">
<figcaption>Nim's Abstract Syntax Tree visualized with a tree</figcaption>
</figure>
<h3>Multiply by two macro</h3>
<p>This example of macro is taken from <a href="https://www.youtube.com/watch?v=WHyOHQ_GkNo">this Youtube video</a> made by <a href="https://www.youtube.com/c/Fireship">Fireship</a>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> timesTwo(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
      <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
        node.intVal = node.intVal*<span class="hljs-number">2</span>

timesTwo:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 2</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 4</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 6</span></code></pre>
<p>This macro multiplies each integer values by two before plotting!
Let us breakdown this macro, shall we ?
To understand how a macro work, we first may look at the AST given as input.</p>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span></code></pre>
<p>By compiling this code, you will get the corresponding AST.
This simple AST is made of four nodes:</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
</code></pre>
<p><code>StmtList</code> stands for <em>statements list</em>. It groups together all the instructions in your block.</p>
<p>The <code>Command</code> node indicates that you use a function whose name is given by its child <code>Ident</code> node. An <code>Ident</code> can be any variable, object, procedure name.</p>
<p>Our integer literal whose value is 1 has the node kind <code>IntLit</code>.</p>
<p>Notice that the order of the nodes in the AST is crucial. If we invert the two last nodes, we would get the AST of the code <code>1 echo</code> which does not compile.</p>
<pre><code class="language-nim">StmtList
  Command
    IntLit 1
    Ident &quot;echo&quot;
</code></pre>
<p><code>StmtList</code>, <code>Command</code>, <code>IntLit</code> and <code>Ident</code> are the NodeKind of the code's AST.
Inside your macro, they are denoted with the extra prefix <code>nnk</code>, e.g. <code>nnkIdent</code>.
You can get the full list of node kinds <a href="https://github.com/nim-lang/Nim/blob/a8c6e36323601a64dcb6947a694f0bde97b632b2/lib/core/macros.nim#L25-L89">at the std/macros source code</a>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> timesTwoAndEcho(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
      <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
        node.intVal = node.intVal*<span class="hljs-number">2</span>
  <span class="hljs-keyword">echo</span> repr <span class="hljs-literal">result</span>

timesTwoAndEcho:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span></code></pre>
<p>The output of a macro is an AST, and we can try to write it for a few examples:</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
</code></pre>
<p>Please note that line breaks are not part of the Nim's AST!</p>
<p>Here, the output AST is almost the same as the input. We only change the integer literal value.</p>
<p>Our root node in the input AST is a statement list.
To fetch the <code>Command</code> children node, we may use the list syntax.
A Node contains the list of its childrens. To get the first children, it suffices to write <code>statements[0]</code>.
To loop over all the child nodes, one can use a <code>for statement in statements</code> loop.</p>
<p>We need to fetch the nodes under a <code>Command</code> instruction that are integer literals.
So for each node in the statement, we test if the node kind is equal to <code>nnkIntLit</code>. We get their value with the attribute <code>node.intVal</code>.</p>
<p>I present down my first macro as an example.
I want to print the memory layout of a given type.
My goal is to find misaligned fields making useless unocuppied memory in a type object definition.
This happens when the attributes have types of different sizes. The order of the attributes then changes the memory used by an object.
To deal with important chunks of memory, the processor stores an object and its attributes with <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">some rules</a>.</p>
<p>It likes when adresses are separated by powers of two. If it is not, it inserts a padding (unoccupied memory) between two attributes.</p>
<p>We can pack a structure with the pragma <code>{.packed.}</code>, which removes this extra space. This has the disadvantage to slow down memory accesses.</p>
<p>We would like to detect the presence of holes in an object.</p>
<p>The first step is to look at the AST of the input code we want to parse.</p>
<p>One can look first at the most basic type definition possible, before trying to complexify the AST to get a feel of all the edge cases.</p>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
      a: <span class="hljs-built_in">float32</span></code></pre>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      Ident &quot;Thing&quot;
      Empty
      ObjectTy
        Empty
        Empty
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
</code></pre>

<p>We have to get outputs as much complex as possible to detect edge cases, while keeping the information to the minimum to easily read the AST and locate errors.
I present here first some samples of type definition on which I will run my macro.</p>
<pre><code class="language-nim">typeMemoryRepr:
  type
    Thing2 = object
      oneChar: char
      myStr: string
  type
    Thing = object of RootObj
      a: float32
      b: uint64
      c: char
</code></pre>
<p>Type with pragmas aren't supported yet</p>
<pre><code class="language-nim">

when false: # erroneous code

  typeMemoryRepr:
    type
      Thing {.packed.} = object
        oneChar: char
        myStr: string
</code></pre>
<p>It is not easy (if even possible) to list all possible types.
Yet by adding some other informations we can get a better picture of the general AST of a type.</p>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      a: <span class="hljs-built_in">float32</span>
      b: <span class="hljs-built_in">string</span></code></pre>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;Thing&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      ObjectTy
        Empty
        OfInherit
          Ident &quot;RootObj&quot;
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
          IdentDefs
            Ident &quot;b&quot;
            Ident &quot;string&quot;
            Empty
</code></pre>
<p>Notice how the name of the type went under the PragmaExpr section. We have to be careful about this when trying to parse the type.</p>
<p>A macro does always the same steps:</p>
<ol>
<li>Search for a node of a specific kind, inside the input AST or check that the given node is of the expected kind.</li>
<li>Fetch properties of the selected node.</li>
<li>Form AST output in function of these input node's properties.</li>
<li>Continue exploring the AST.</li>
</ol>
<p>Your macros will require a long docstring and many comments both with thorough details.</p>
<p>I present now my macro <code>typeMemoryRepr</code> inspired from the <a href="https://zevv.nl/nim-memory/">nim memory guide</a> on memory representation.
In this guide, we manually print types fields address, to get an idea of the memory layout and the space taken by each variable and its fields.</p>
<pre><code class="language-nim">type Thing = object
  a: uint32
  b: uint8
  c: uint16

var t: Thing

echo &quot;size t.a &quot;, t.a.sizeof
echo &quot;size t.b &quot;, t.b.sizeof
echo &quot;size t.c &quot;, t.c.sizeof
echo &quot;size t   &quot;, t.sizeof

echo &quot;addr t.a &quot;, t.a.addr.repr
echo &quot;addr t.b &quot;, t.b.addr.repr
echo &quot;addr t.c &quot;, t.c.addr.repr
echo &quot;addr t   &quot;, t.addr.repr
</code></pre>
<p>All these echo's are redundant and have to be changed each time we change the type field. For types with more than four or five fields, this becomes not manageable.</p>
<p>I have split this macro into different procedures.
The <code>echoSizeVarFieldStmt</code> will take the name of a variable, let us say <code>a</code> and of its field <code>field</code> and return the code:</p>
<pre><code class="language-nim">echo a.field.sizeof
</code></pre>
<p>We create a NimNode of kind <code>StmtList</code> (a statement list), that contains <code>IdentNode</code>s.
The first <code>IdentNode</code> is the command <code>echo</code>.
We do not represent spaces in the AST. Each term separated by a dot is an Ident and part of a <code>nnkDotExpr</code>.</p>
<p>It suffices to output the above code under a <code>dumpTree</code> block, to understand the AST we have to generate.</p>
<pre><code class="language-nim">dumpTree:
  echo a.field.sizeof
</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> echoSizeVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
  <span class="hljs-comment">## quote do:</span>
  <span class="hljs-comment">##   echo `variable`.`nameOfField`.sizeof</span>
  newStmtList(nnkCommand.newTree(
            newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
            nnkDotExpr.newTree(
              nnkDotExpr.newTree(
                newIdentNode(variable),
                newIdentNode(nameOfField) <span class="hljs-comment"># The name of the field is the first ident</span>
                ),
                newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
            )
            ))</code></pre>
<p>The <code>echoAddressVarFieldStmt</code> will take the name of a variable, let us say <code>a</code> and of its field <code>field</code> and return its address:</p>
<pre><code class="language-nim">echo a.field.addr.repr
</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> echoAddressVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
  <span class="hljs-comment">## quote do:</span>
  <span class="hljs-comment">##   echo `variable`.`nameOfField`.addr.repr</span>
  newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    newIdentNode(variable),
                    newIdentNode(nameOfField)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                ),
                newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
              )
              ))</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-comment">## This macro takes a type definition as an argument and:</span>
  <span class="hljs-comment">## * defines the type (outputs typedef as is)</span>
  <span class="hljs-comment">## * initializes a variable of this type</span>
  <span class="hljs-comment">## * echoes the size and address of the variable</span>
  <span class="hljs-comment">## Then, for each field:</span>
  <span class="hljs-comment">## * echoes the size and address of the variable field</span>

  <span class="hljs-comment"># We begin by running the type definition.</span>
  <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
    `typedef`

  <span class="hljs-comment"># Parse the type definition to find the TypeDef section's node</span>
  <span class="hljs-comment"># We create the output's AST along parsing.</span>
  <span class="hljs-comment"># We will receive a statement list as the root of the AST</span>
  <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
    <span class="hljs-comment"># We select only the type section in the StmtList</span>
    <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
      <span class="hljs-keyword">let</span> typeSection = statement
      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
        <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
          <span class="hljs-keyword">var</span> tnode = typeSection[i]
          <span class="hljs-comment"># The name of the type is the first Ident child. We can get the ident's string with strVal or repr</span>
          <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

          <span class="hljs-comment">## Generation of AST:</span>
          <span class="hljs-comment"># We create a variable of the given type definition (hopefully not already defined) name for the &quot;myTypenameVar&quot;</span>
          <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
          <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)
          <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
          quote <span class="hljs-keyword">do</span>:
            <span class="hljs-keyword">var</span> `testVariable`:`nameOfType` <span class="hljs-comment"># instanciate variable with type defined in typedef</span>
            <span class="hljs-keyword">echo</span> `testVariable`.sizeof <span class="hljs-comment"># echo the total size</span>
            <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr <span class="hljs-comment"># gives the address in memory</span>
          )
          <span class="hljs-comment"># myTypeVar.field[i] memory size and address in memory</span>
          tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-comment"># The third child of the third child is the fields's AST</span>
          <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList
          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
            <span class="hljs-comment"># myTypeVar.field[i].sizeof</span>
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoSizeVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))
            <span class="hljs-comment"># myTypeVar.field[i].addr.repr</span>
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoAddressVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))

  <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr</code></pre>
<pre><code class="nohighlight hljs nim">typeMemoryRepr:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      a: <span class="hljs-built_in">float32</span>
      b: <span class="hljs-built_in">string</span></code></pre><pre class="nb-output">32
ptr Thing(a: 0.0, b: &quot;&quot;)
4
ptr 0.0
16
ptr &quot;&quot;</pre>
<p>Trying to parse a type ourselve is risky, since there are numerous easily forgettable possibilities (due to pragma expressions, cyclic types, and many kind of types: object, enum, type alias, etc..., case of fields, branching and conditionals inside the object, ‚Ä¶ ).</p>
<p>There is actually already a function to do so and this will be the object of a future release of this tutorial.</p>
<p>The following macro enables to create enums with power of two values.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/[enumerate, math]</code></pre>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># jmgomez on Discord</span>
<span class="hljs-keyword">macro</span> power2Enum(body: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">let</span> srcFields = body[^<span class="hljs-number">1</span>][<span class="hljs-number">1.</span>.^<span class="hljs-number">1</span>]
  <span class="hljs-keyword">var</span> dstFields =  nnkEnumTy.newTree(newEmptyNode())
  <span class="hljs-keyword">for</span> idx, field <span class="hljs-keyword">in</span> enumerate(srcFields):
    dstFields.add nnkEnumFieldDef.newTree(field, newIntLitNode(pow(<span class="hljs-number">2.0</span>, idx.<span class="hljs-built_in">float</span>).<span class="hljs-built_in">int</span>))

  body[^<span class="hljs-number">1</span>] = dstFields
  <span class="hljs-keyword">echo</span> repr body
  body


<span class="hljs-keyword">type</span> <span class="hljs-type">Test</span> {.power2Enum.}  = <span class="hljs-keyword">enum</span>
  a, b, c, d</code></pre>
<p>A macro is not always the best alternative. A simple set and a cast gives the same result.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># Rika</span>
<span class="hljs-keyword">type</span>
  <span class="hljs-type">Setting</span> = <span class="hljs-keyword">enum</span>
    a, b, c
  <span class="hljs-type">Settings</span> = <span class="hljs-built_in">set</span>[<span class="hljs-type">Setting</span>]
<span class="hljs-keyword">let</span> settings: <span class="hljs-type">Settings</span> = {a, c}
<span class="hljs-keyword">echo</span> <span class="hljs-keyword">cast</span>[<span class="hljs-built_in">uint8</span>](settings)</code></pre><pre class="nb-output">5</pre>
<p><a name = "references-and-bibliography"></a></p>
<h2>References and Bibliography</h2>
<hr />
<p>Press <code>Ctrl</code> + <code>Click</code> to open following links in a new tab.</p>
<p>First, there are four official resources at the Nim's website:</p>
<ol>
<li><a href="https://nim-by-example.github.io/macros/">Nim by Example</a></li>
<li><a href="https://nim-lang.org/docs/tut3.html">Nim Tutorial (Part III)</a></li>
<li><a href="https://nim-lang.org/docs/manual.html#macros">Manual section about macros</a></li>
<li><a href="https://nim-lang.org/docs/macros.html">The Standard Documentation of the std/macros library</a>
The 2. and 3. documentations are complementary learning resources while the last one will be your up-to-date exhaustive reference. It provides dumped AST (explained later) for all the nodes.</li>
</ol>
<p>Many developers have written their macro's tutorial:</p>
<ol>
<li><a href="https://learnxinyminutes.com/docs/nim/">Nim in Y minutes</a></li>
<li><a href="https://dev.to/beef331/demystification-of-macros-in-nim-13n8">Jason Beetham a.k.a ElegantBeef's dev.to tutorial</a>. This tutorial contains a lot of good first examples.</li>
<li><a href="https://www.youtube.com/watch?v=GJpn6SfR_1M">Pattern matching (sadly outdated) in macros by DevOnDuty</a></li>
<li><a href="https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro">Tomohiro's FAQ section about macros</a></li>
<li><a href="https://flyx.org/nimyaml-making-of/">The Making of NimYAML's article of flyx</a></li>
</ol>
<p>There are plentiful of posts in the forum that are good references:</p>
<ol>
<li><a href="https://forum.nim-lang.org/t/2587">What is &quot;Metaprogramming&quot; paradigm used for ?</a></li>
<li><a href="https://forum.nim-lang.org/t/9470">Custom macro inserts macro help</a></li>
<li><a href="https://forum.nim-lang.org/t/9498">See generated code after template processing</a></li>
<li><a href="https://forum.nim-lang.org/t/10037">Fast array assignment</a></li>
<li><a href="https://forum.nim-lang.org/t/10513">Variable injection</a></li>
<li><a href="https://forum.nim-lang.org/t/9127">Proc inspection</a></li>
<li>etc ‚Ä¶ Please use the forum search bar with specific keywords like <code>macro</code>, <code>metaprogramming</code>, <code>generics</code>, <code>template</code>, ‚Ä¶</li>
</ol>
<p>Last but no least, there are three Nim books:</p>
<ol>
<li><a href="https://book.picheta.me">Nim In Action, ed. Manning</a> and <a href="https://github.com/dom96/nim-in-action-code">github repo</a></li>
<li><a href="https://www.amazon.fr/dp/B0B4R7B9YX">Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator</a>.</li>
<li><a href="https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming">Nim Programming Book, by S.Salewski</a></li>
</ol>
<p>We can also count many projects that are macro- or template-based:</p>
<ol>
<li>
<p><a href="https://github.com/treeform/genny">genny</a> and <a href="https://github.com/treeform/genny">benchy</a>. Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
In general, treeform projects source code are good Nim references</p>
</li>
<li>
<p>My favorite DSL : the <a href="https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim">neural network domain specific language (DSL) of the tensor library Arraymancer</a>
<a href="https://github.com/mratsim/">mratsim</a> develops this library, and made <a href="https://forum.nim-lang.org/t/9551#62851">a list of all his DSL</a> in the forum.</p>
</li>
<li>
<p><a href="https://github.com/dom96/jester">Jester</a> library is a HTML DSL, where each block defines a route in your web application.</p>
</li>
<li>
<p><a href="https://pietroppeter.github.io/nimib/">nimib</a> with which this blog post has been written.</p>
</li>
<li>
<p><a href="https://github.com/jmgomez/NimForUE">Nim4UE</a>. You can develop Nim code for the Unreal Engine 5 game engine. The macro system parses your procs and outputs DLL for UE.</p>
</li>
</ol>
</main>
<footer>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nohighlight nim hljs"><span class="hljs-keyword">import</span> std/[strutils, macros]
<span class="hljs-keyword">import</span> std/[enumerate, math]
<span class="hljs-keyword">import</span> nimib, nimoji

nbInit

<span class="hljs-comment"># add a ToC</span>
<span class="hljs-keyword">var</span> nbToc: <span class="hljs-type">NbBlock</span>

<span class="hljs-keyword">template</span> addToc =
  newNbBlock(<span class="hljs-string">&quot;nbText&quot;</span>, <span class="hljs-literal">false</span>, nb, nbToc, <span class="hljs-string">&quot;&quot;</span>):
    nbToc.output = <span class="hljs-string">&quot;### Plan:</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

<span class="hljs-keyword">template</span> nbSection(name:<span class="hljs-built_in">string</span>) =
  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;1. &lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
&lt;h1 style=&quot;text-align: center;&quot;&gt;Les macros avec Nim - tutoriel de m√©taprogrammation&lt;/h1&gt;

Ce tutoriel a pour objectif d'√™tre une introduction aux capacit√©s de m√©taprogrammation du langage de programmation Nim. Il vise √† donner autant de d√©tails que possible pour d√©marrer vos projets les plus fous.
Il existe de nombreuses ressources que ce soit √† travers les livres ou sur Internet mais vous devriez trouvez ici (√† terme) une description compl√®te du processus de d√©veloppement de macros.

&quot;&quot;&quot;</span>

addToc()

nbSection <span class="hljs-string">&quot;Introduction&quot;</span>
nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
&gt; Qu'est-ce que la m√©taprogrammation ?

La m√©taprogrammation consiste √† programmer du code informatique. Autrement dit, l'entr√©e et la sortie de programmes r√©alisant de la m√©taprogrammation seront eux-m√™mes des bouts de code.

&gt; Mon language pr√©f√©r√© ne me permet pas d'√©crire des macros. Pourquoi √©crire des macros (avec Nim)?

Le principal objectif est d'√©crire facilement des longues portions de code qui sont r√©p√©titives ou pour s'adapter par exemple √† de nombreuses architectures.
Il est √©galement possible d'√©crire de mini-langages de programmation nomm√©s DSL (&quot;domain-specific languages&quot;) pour une utilisation pr√©cise, comme la description de contenu d'une fen√™tre graphique avec `Owlkettle`
ou pour sp√©cifier les param√®tres d'un r√©seau de neurones `Arraymancer`. Les macros sont √©crites une fois par le d√©veloppeur d'une biblioth√®que, et les utilisateurs de cette biblioth√®que vont voir leur code modifi√©
par les macros sans m√™me utiliser de macros par eux-m√™mes.

&gt; Quel rapport avec les macros ?

Les macros sont ces fonctions qui vont travailler sur des bouts de code et g√©n√©rer du code en sortie. Nous verrons par la suite que ce code est repr√©sent√©
sous la forme d'arbre syntaxique nomm√© AST.
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
### Quatre niveaux d'abstraction
Il existe quatre niveaux d'abstraction en m√©taprogrammation qui sont chacun associ√©s √† un type de proc√©dure ou it√©rateur:

  0. Proc√©dures/fonctions/it√©rateurs ordinaires (Pas de m√©taprogrammation)
  1. Les proc√©dures g√©n√©riques et les classes de type (M√©taprogrammation au niveau du type)
  2. Les ¬´ mod√®les ¬ª `template` en anglais (Un m√©chanisme de copier-coller avanc√©)
  3. Les `Macro`s (Substitution d'arbre syntaxique `AST`)

Il faut garder en t√™te que la m√©taprogrammation est un m√©chanisme complexe, et il est fortement recommand√© d'utiliser le niveau d'abstraction le plus faible possible,
et pas de m√©taprogrammation du tout lorsque cela est possible. Il existe plusieurs raisons √† cela. Premi√®rement, il est difficile de relire du code source utilisant de la
m√©taprogrammation. Cela demande beaucoup de temps pour v√©rifier que le code source ne g√©n√®re pas d'erreur et trouver l'origine d'une erreur s'il y en a une.
Sans commentaire, une macro est presque illisible. Vous verrez par la suite qu'il est difficile de comprendre l'objectif et le fonctionnement d'une macro rien qu'en la lisant.
Deuxi√®mement, il est difficile de faire de la gestion d'exception lorsqu'on manipule du code source. Il faut v√©rifier le code source qu'on re√ßoit en entr√©e d'une macro, et comme
les possibilit√©s sont tr√®s nombreuses, il est presque impossible de trier des codes sources valides en entr√©e d'une macro. Cela pose des probl√©matiques de s√©curit√© √©videntes. C'est une des raisons
pour laquelle la plupart des langages de programmation ont √©vit√© d'introduire des capacit√©s de m√©taprogrammation. Enfin, les temps de compilation sont proportionnels au travail que doit r√©aliser le
compilateur. Plus le niveau de m√©taprogrammation est avanc√©, plus le temps de compilation augmente, rendant le d√©veloppement plus complexe et for√ßant ainsi la fragmentation du code en plusieurs modules.

Je vous propose dans ce tutoriel une pr√©sentation de ces quatre niveaux de m√©taprogrammation. Nous verrons au passage des notions n√©cessaires au d√©veloppement de macros, comme les param√®tres non typ√©s,
l'hygi√©nisation des variables, l'introspection de code, les arbres syntaxiques. En bonus, nous verrons des bouts de code (¬´ snippets ¬ª en anglais) qui vous seront peut-√™tre utiles en dehors de la m√©taprogrammation.
Avant d'aborder les macros et les arbres syntaxiques, nous commen√ßons donc avec les proc√©dures g√©n√©riques, puis les mod√®les avec les param√®tres non typ√©s.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">import</span> std/macros

nbSection <span class="hljs-string">&quot;Proc√©dures G√©n√©riques&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
Un des objectifs de la programmation est l'automatisation de t√¢ches r√©p√©titives.
Certains programmes sont fastidieux √† √©crire et nous √©crivons souvent des codes similaires.

Imaginez que vous voulez programmer une addition. Votre algorithme est probablement g√©n√©ral et ne d√©pend peut-√™tre pas du type de l'entr√©e. Votre algorithme pourrait recevoir
aussi bien des entiers que des nombres flottants en entr√©e.

Vous ne voulez pas r√©√©crire chacun de vos algorithmes pour chacun des types qui conviendraient.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment"># What to not do!</span>
  <span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =
    <span class="hljs-keyword">return</span> x + y

  <span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">float</span>): <span class="hljs-built_in">float</span> =
    <span class="hljs-keyword">return</span> x + y

  <span class="hljs-keyword">echo</span> add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
  <span class="hljs-keyword">echo</span> add(<span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span>)

nbText:<span class="hljs-string">&quot;&quot;&quot;
En effet, que se passerait-il si vous vouliez ajouter une fonction pour un autre type comme `int32` ou `float16`?
Vous devrez alors copier-coller votre fonction et changer le type. Bien que cela semble anodin, cela se r√©v√®le vite probl√©matique lorsque vous trouvez un bug dans l'algorithme.

Il vous faut alors corriger autant de fonctions que de types support√©s. De plus, le code devient peu lisible, puisque chaque fonction appara√Æt de nombreuses fois.

Une premi√®re solution consiste √† utiliser les types ¬´ g√©n√©riques implicites ¬ª. On utilise le mot-cl√© `or` comme pour une expression bool√©enne avec les types qui conviendraient.
Durant la phase de compilation, le compilateur Nim choisit quel type convient √† la situation.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">proc</span> add(x,y: (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>)): (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>) =
    <span class="hljs-keyword">return</span> x + y

  add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
  add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Il se peut que vous ne sachiez pas vraiment √† l'avance combien de types exactement pourrait √™tre utilis√©s pour votre algorithme.
Vous voudriez peut-√™tre faire des modifications pour certains types pr√©cis. Il convient alors d'utiliser un type g√©n√©rique (non implicite).
Il s'agit d'un type repr√©sent√© par une variable. Par convention, on d√©signe cette variable par une lettre majuscule qui est souvent T, U, V, etc ‚Ä¶
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">proc</span> add[<span class="hljs-type">T</span>](x,y: <span class="hljs-type">T</span>): <span class="hljs-type">T</span> =
    <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
      x = x.parseFloat()
      y = y.parseFloat()
    <span class="hljs-keyword">var</span> c = x + y
    <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
      <span class="hljs-keyword">return</span> $c
    <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">return</span> c

  add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
  add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span>
  add <span class="hljs-string">&quot;3.7&quot;</span>, <span class="hljs-string">&quot;4.5&quot;</span>

nbSection <span class="hljs-string">&quot;Templates&quot;</span>
nbText:<span class="hljs-string">&quot;&quot;&quot;
:warning: Afin d'ex√©cuter chaque code dans la suite de ce tutoriel, vous devrez importer le paquet `std/macros`.
&quot;&quot;&quot;</span>.emojize

nbCodeSkip:
  <span class="hljs-keyword">import</span> std/macros

nbText: <span class="hljs-string">&quot;&quot;&quot;
Nous pouvons voir les *templates* comme des proc√©dures qui font de la substitution de code, comme un couper-coller qui serait r√©alis√© √† la compilation.

Les proc√©dures `templates` re√ßoivent g√©n√©ralement en dernier param√®tre un bout de code.
Le type qui correspond √† un bout de code est `untyped`.
Comme nous souhaitons que le template retourne un bout de code, le type de retour est `untyped` pour presque tous les cas d'usage.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">not</span> (a == b)

nbText:<span class="hljs-string">&quot;&quot;&quot;
:warning: Le reste du tutoriel n'a pas encore √©t√© traduit de l'anglais vers le fran√ßais.
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
The Nim language defines boolean operators like `!=` with templates. You can even look at Nim's source code, that's almost the same code. See the [documentation](https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped).
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment">## Example from std/manual</span>
  <span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">not</span> (a == b)

  doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>)

nbText: <span class="hljs-string">&quot;&quot;&quot;
We can easily repeat code under a custom block. Here duplicate, just duplicate code and repeat takes an additional parameter, an int, as a generalisation of the `duplicate` template.
Notice that duplicate is not smart. It will repeat any assignment twice in the code's block.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
    statements
    statements

  duplicate:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span>

nbCode:
  <span class="hljs-comment">## Example from Nim In Action</span>
  <span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep
  <span class="hljs-keyword">template</span> repeat(count: <span class="hljs-built_in">int</span>, statements: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; count:
      statements

  repeat <span class="hljs-number">5</span>:
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Hello Templates!&quot;</span>)
    sleep(<span class="hljs-number">100</span>)

nbText: <span class="hljs-string">&quot;&quot;&quot;
#### Do-While keyword
In Nim, there are few restricted keywords and special control-flow mechanisms, as to incite us to create our own constructs (and keep the language simple). Nothing restrains us from defining a `doWhile` construct similar to languages like `C` or `Javascript`.

For those only knowing Nim, this construct enables to run a loop once before testing the condition.

This C code always print `Hello World` at least once independantly from the start value of the variable `i`.
```cpp
int i = 10;
do{
  printf(&quot;Hello World&quot;);
  i += 1;
}while(i &lt; 10);
```
&quot;&quot;&quot;</span>

nbCode:

  <span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
    loop
    <span class="hljs-keyword">while</span> conditional:
      loop

  <span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>
  doWhile i &lt; <span class="hljs-number">10</span>:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span>
      i.inc

nbText:<span class="hljs-string">hlMd&quot;&quot;&quot;
Notice though that _syntaxically_ the resulting source code is fairly different than the C++ code.

In the C source code, appear in this order:
  1. the `do` keyword
  2. the block of instruction
  3. the `while` keyword
  4. the conditional (boolean expression)

In Nim, we have in this order:
  1. the `doWhile` indent
  2. the conditional
  3. block of instruction

There is no way to modify Nim's syntax as to match C's syntax.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
#### Benchmark example
Another example is benchmarking code in Nim. It suffices to put our bench code inside a special block.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">import</span> std/[times, monotimes]
  <span class="hljs-keyword">template</span> benchmark(benchmarkName: <span class="hljs-built_in">string</span>, code: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">block</span>:
      <span class="hljs-keyword">let</span> t0 = getMonoTime()
      code
      <span class="hljs-keyword">let</span> elapsed = getMonoTime() - t0
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, benchmarkName, <span class="hljs-string">&quot;] &quot;</span>, elapsed

  benchmark <span class="hljs-string">&quot;test1&quot;</span>:
    sleep(<span class="hljs-number">100</span>)

nbText:<span class="hljs-string">&quot;&quot;&quot;
The code inside the `benchmark` code block will be enclosed by our template code.

Since the code replacement is done at compile time, this transformation does not add additional runtime to our benchmarked code.
On the contrary, a function or procedure for benchmarking would have add runtime due to the nested function calls.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Macros&quot;</span>
nbText:<span class="hljs-string">&quot;&quot;&quot;
Template uses `untyped` parameters as lego bricks. It can not break it down into smaller pieces.
We can not check untyped parameters in a template. If our template works when given an object as argument, nothing restrics an user to give a function as argument.

Macros can be seen as an empowered template procedure. While template substitute code, macros do introspection.
The main difference is that a template can not look inside an untyped parameter. This means that we can not check the input we get as to verify that the user did not give a function when we expect a type.


One can parse untyped parameters with macros. We can even act something conditionally to informations given in these parameters.
We can also inject variables into scopes.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">macro</span> throwAway(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-literal">result</span> = newStmtList()

  throwAway:
    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;If you do not throw me, I'll spam you indefinitely!&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
### AST Manipulation
In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST). To get a representation of the AST corresponding to a code, we can use the `macro` `dumpTree`.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment"># Don't forget to import std/macros!</span>
  <span class="hljs-comment"># You can use --hints:off to display only the AST tree</span>
  dumpTree:
    <span class="hljs-keyword">type</span>
      myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        left: <span class="hljs-built_in">seq</span>[myObject]
        right: <span class="hljs-built_in">seq</span>[myObject]

nbText:<span class="hljs-string">&quot;&quot;&quot;
This code outputs the following AST tree (it should not change among Nim versions).
```nim
StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
```
We can better visualize the tree structure of the AST with the following picture.
&quot;&quot;&quot;</span>

nbImage(url=<span class="hljs-string">&quot;ASTtree.jpg&quot;</span>, caption=<span class="hljs-string">&quot;Nim's Abstract Syntax Tree visualized with a tree&quot;</span>)

nbText:<span class="hljs-string">&quot;&quot;&quot;
### Multiply by two macro
This example of macro is taken from [this Youtube video](https://www.youtube.com/watch?v=WHyOHQ_GkNo) made by [Fireship](https://www.youtube.com/c/Fireship).
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">macro</span> timesTwo(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
      <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
          node.intVal = node.intVal*<span class="hljs-number">2</span>

  timesTwo:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 2</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 4</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 6</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
This macro multiplies each integer values by two before plotting!
Let us breakdown this macro, shall we ?
To understand how a macro work, we first may look at the AST given as input.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
By compiling this code, you will get the corresponding AST.
This simple AST is made of four nodes:
```nim
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
```

`StmtList` stands for *statements list*. It groups together all the instructions in your block.

The `Command` node indicates that you use a function whose name is given by its child `Ident` node. An `Ident` can be any variable, object, procedure name.

Our integer literal whose value is 1 has the node kind `IntLit`.

Notice that the order of the nodes in the AST is crucial. If we invert the two last nodes, we would get the AST of the code `1 echo` which does not compile.
```nim
StmtList
  Command
    IntLit 1
    Ident &quot;echo&quot;
```

`StmtList`, `Command`, `IntLit` and `Ident` are the NodeKind of the code's AST.
Inside your macro, they are denoted with the extra prefix `nnk`, e.g. `nnkIdent`.
You can get the full list of node kinds [at the std/macros source code](https://github.com/nim-lang/Nim/blob/a8c6e36323601a64dcb6947a694f0bde97b632b2/lib/core/macros.nim#L25-L89).
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">macro</span> timesTwoAndEcho(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
      <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
          node.intVal = node.intVal*<span class="hljs-number">2</span>
    <span class="hljs-keyword">echo</span> repr <span class="hljs-literal">result</span>

  timesTwoAndEcho:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
The output of a macro is an AST, and we can try to write it for a few examples:
```nim
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
```
Please note that line breaks are not part of the Nim's AST!

Here, the output AST is almost the same as the input. We only change the integer literal value.

Our root node in the input AST is a statement list.
To fetch the `Command` children node, we may use the list syntax.
A Node contains the list of its childrens. To get the first children, it suffices to write `statements[0]`.
To loop over all the child nodes, one can use a `for statement in statements` loop.

We need to fetch the nodes under a `Command` instruction that are integer literals.
So for each node in the statement, we test if the node kind is equal to `nnkIntLit`. We get their value with the attribute `node.intVal`.
&quot;&quot;&quot;</span>


nbText:<span class="hljs-string">&quot;&quot;&quot;
I present down my first macro as an example.
I want to print the memory layout of a given type.
My goal is to find misaligned fields making useless unocuppied memory in a type object definition.
This happens when the attributes have types of different sizes. The order of the attributes then changes the memory used by an object.
To deal with important chunks of memory, the processor stores an object and its attributes with [some rules](https://en.wikipedia.org/wiki/Data_structure_alignment).

It likes when adresses are separated by powers of two. If it is not, it inserts a padding (unoccupied memory) between two attributes.

We can pack a structure with the pragma `{.packed.}`, which removes this extra space. This has the disadvantage to slow down memory accesses.

We would like to detect the presence of holes in an object.

The first step is to look at the AST of the input code we want to parse.

One can look first at the most basic type definition possible, before trying to complexify the AST to get a feel of all the edge cases.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
        a: <span class="hljs-built_in">float32</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
```nim
StmtList
  TypeSection
    TypeDef
      Ident &quot;Thing&quot;
      Empty
      ObjectTy
        Empty
        Empty
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;

&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
We have to get outputs as much complex as possible to detect edge cases, while keeping the information to the minimum to easily read the AST and locate errors.
I present here first some samples of type definition on which I will run my macro.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">hlMd&quot;&quot;&quot;
```nim
typeMemoryRepr:
  type
    Thing2 = object
      oneChar: char
      myStr: string
  type
    Thing = object of RootObj
      a: float32
      b: uint64
      c: char
```

Type with pragmas aren't supported yet
```nim


when false: # erroneous code

  typeMemoryRepr:
    type
      Thing {.packed.} = object
        oneChar: char
        myStr: string
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
It is not easy (if even possible) to list all possible types.
Yet by adding some other informations we can get a better picture of the general AST of a type.
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        a: <span class="hljs-built_in">float32</span>
        b: <span class="hljs-built_in">string</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
```nim
StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;Thing&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      ObjectTy
        Empty
        OfInherit
          Ident &quot;RootObj&quot;
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
          IdentDefs
            Ident &quot;b&quot;
            Ident &quot;string&quot;
            Empty
```
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Notice how the name of the type went under the PragmaExpr section. We have to be careful about this when trying to parse the type.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
A macro does always the same steps:

  1. Search for a node of a specific kind, inside the input AST or check that the given node is of the expected kind.
  2. Fetch properties of the selected node.
  3. Form AST output in function of these input node's properties.
  4. Continue exploring the AST.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Your macros will require a long docstring and many comments both with thorough details.

I present now my macro `typeMemoryRepr` inspired from the [nim memory guide](https://zevv.nl/nim-memory/) on memory representation.
In this guide, we manually print types fields address, to get an idea of the memory layout and the space taken by each variable and its fields.

```nim
type Thing = object
  a: uint32
  b: uint8
  c: uint16

var t: Thing

echo &quot;size t.a &quot;, t.a.sizeof
echo &quot;size t.b &quot;, t.b.sizeof
echo &quot;size t.c &quot;, t.c.sizeof
echo &quot;size t   &quot;, t.sizeof

echo &quot;addr t.a &quot;, t.a.addr.repr
echo &quot;addr t.b &quot;, t.b.addr.repr
echo &quot;addr t.c &quot;, t.c.addr.repr
echo &quot;addr t   &quot;, t.addr.repr
```

All these echo's are redundant and have to be changed each time we change the type field. For types with more than four or five fields, this becomes not manageable.

I have split this macro into different procedures.
The `echoSizeVarFieldStmt` will take the name of a variable, let us say `a` and of its field `field` and return the code:
```nim
echo a.field.sizeof
```
We create a NimNode of kind `StmtList` (a statement list), that contains `IdentNode`s.
The first `IdentNode` is the command `echo`.
We do not represent spaces in the AST. Each term separated by a dot is an Ident and part of a `nnkDotExpr`.

It suffices to output the above code under a `dumpTree` block, to understand the AST we have to generate.
```nim
dumpTree:
  echo a.field.sizeof
```
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> echoSizeVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
    <span class="hljs-comment">## quote do:</span>
    <span class="hljs-comment">##   echo `variable`.`nameOfField`.sizeof</span>
    newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  newIdentNode(variable),
                  newIdentNode(nameOfField) <span class="hljs-comment"># The name of the field is the first ident</span>
                  ),
                  newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
              )
              ))

nbText:<span class="hljs-string">&quot;&quot;&quot;
The `echoAddressVarFieldStmt` will take the name of a variable, let us say `a` and of its field `field` and return its address:
```nim
echo a.field.addr.repr
```
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">proc</span> echoAddressVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
    <span class="hljs-comment">## quote do:</span>
    <span class="hljs-comment">##   echo `variable`.`nameOfField`.addr.repr</span>
    newStmtList(nnkCommand.newTree(
                newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    nnkDotExpr.newTree(
                      newIdentNode(variable),
                      newIdentNode(nameOfField)
                    ),
                    newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
                )
                ))


nbCode:
  <span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-comment">## This macro takes a type definition as an argument and:</span>
    <span class="hljs-comment">## * defines the type (outputs typedef as is)</span>
    <span class="hljs-comment">## * initializes a variable of this type</span>
    <span class="hljs-comment">## * echoes the size and address of the variable</span>
    <span class="hljs-comment">## Then, for each field:</span>
    <span class="hljs-comment">## * echoes the size and address of the variable field</span>

    <span class="hljs-comment"># We begin by running the type definition.</span>
    <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
      `typedef`

    <span class="hljs-comment"># Parse the type definition to find the TypeDef section's node</span>
    <span class="hljs-comment"># We create the output's AST along parsing.</span>
    <span class="hljs-comment"># We will receive a statement list as the root of the AST</span>
    <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
      <span class="hljs-comment"># We select only the type section in the StmtList</span>
      <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
        <span class="hljs-keyword">let</span> typeSection = statement
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
          <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
            <span class="hljs-keyword">var</span> tnode = typeSection[i]
            <span class="hljs-comment"># The name of the type is the first Ident child. We can get the ident's string with strVal or repr</span>
            <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

            <span class="hljs-comment">## Generation of AST:</span>
            <span class="hljs-comment"># We create a variable of the given type definition (hopefully not already defined) name for the &quot;myTypenameVar&quot;</span>
            <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
            <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
            quote <span class="hljs-keyword">do</span>:
              <span class="hljs-keyword">var</span> `testVariable`:`nameOfType` <span class="hljs-comment"># instanciate variable with type defined in typedef</span>
              <span class="hljs-keyword">echo</span> `testVariable`.sizeof <span class="hljs-comment"># echo the total size</span>
              <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr <span class="hljs-comment"># gives the address in memory</span>
            )
            <span class="hljs-comment"># myTypeVar.field[i] memory size and address in memory</span>
            tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] <span class="hljs-comment"># The third child of the third child is the fields's AST</span>
            <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
              <span class="hljs-comment"># myTypeVar.field[i].sizeof</span>
              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoSizeVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))
              <span class="hljs-comment"># myTypeVar.field[i].addr.repr</span>
              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoAddressVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))

    <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr

nbCode:
  typeMemoryRepr:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        a: <span class="hljs-built_in">float32</span>
        b: <span class="hljs-built_in">string</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Trying to parse a type ourselve is risky, since there are numerous easily forgettable possibilities (due to pragma expressions, cyclic types, and many kind of types: object, enum, type alias, etc..., case of fields, branching and conditionals inside the object, ‚Ä¶ ).

There is actually already a function to do so and this will be the object of a future release of this tutorial.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
The following macro enables to create enums with power of two values.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">import</span> std/[enumerate, math]

nbCode:
  <span class="hljs-comment"># jmgomez on Discord</span>
  <span class="hljs-keyword">macro</span> power2Enum(body: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">let</span> srcFields = body[^<span class="hljs-number">1</span>][<span class="hljs-number">1.</span>.^<span class="hljs-number">1</span>]
    <span class="hljs-keyword">var</span> dstFields =  nnkEnumTy.newTree(newEmptyNode())
    <span class="hljs-keyword">for</span> idx, field <span class="hljs-keyword">in</span> enumerate(srcFields):
      dstFields.add nnkEnumFieldDef.newTree(field, newIntLitNode(pow(<span class="hljs-number">2.0</span>, idx.<span class="hljs-built_in">float</span>).<span class="hljs-built_in">int</span>))

    body[^<span class="hljs-number">1</span>] = dstFields
    <span class="hljs-keyword">echo</span> repr body
    body


  <span class="hljs-keyword">type</span> <span class="hljs-type">Test</span> {.power2Enum.}  = <span class="hljs-keyword">enum</span>
    a, b, c, d

nbText:<span class="hljs-string">&quot;&quot;&quot;
A macro is not always the best alternative. A simple set and a cast gives the same result.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment"># Rika</span>
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Setting</span> = <span class="hljs-keyword">enum</span>
      a, b, c
    <span class="hljs-type">Settings</span> = <span class="hljs-built_in">set</span>[<span class="hljs-type">Setting</span>]
  <span class="hljs-keyword">let</span> settings: <span class="hljs-type">Settings</span> = {a, c}
  <span class="hljs-keyword">echo</span> <span class="hljs-keyword">cast</span>[<span class="hljs-built_in">uint8</span>](settings)

nbSection <span class="hljs-string">&quot;References and Bibliography&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
Press `Ctrl` + `Click` to open following links in a new tab.

First, there are four official resources at the Nim's website:
  1. [Nim by Example](https://nim-by-example.github.io/macros/)
  2. [Nim Tutorial (Part III)](https://nim-lang.org/docs/tut3.html)
  3. [Manual section about macros](https://nim-lang.org/docs/manual.html#macros)
  4. [The Standard Documentation of the std/macros library](https://nim-lang.org/docs/macros.html)
The 2. and 3. documentations are complementary learning resources while the last one will be your up-to-date exhaustive reference. It provides dumped AST (explained later) for all the nodes.

Many developers have written their macro's tutorial:
  1. [Nim in Y minutes](https://learnxinyminutes.com/docs/nim/)
  2. [Jason Beetham a.k.a ElegantBeef's dev.to tutorial](https://dev.to/beef331/demystification-of-macros-in-nim-13n8). This tutorial contains a lot of good first examples.
  3. [Pattern matching (sadly outdated) in macros by DevOnDuty](https://www.youtube.com/watch?v=GJpn6SfR_1M)
  4. [Tomohiro's FAQ section about macros](https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro)
  5. [The Making of NimYAML's article of flyx](https://flyx.org/nimyaml-making-of/)

There are plentiful of posts in the forum that are good references:
  1. [What is &quot;Metaprogramming&quot; paradigm used for ?](https://forum.nim-lang.org/t/2587)
  2. [Custom macro inserts macro help](https://forum.nim-lang.org/t/9470)
  3. [See generated code after template processing](https://forum.nim-lang.org/t/9498)
  4. [Fast array assignment](https://forum.nim-lang.org/t/10037)
  5. [Variable injection](https://forum.nim-lang.org/t/10513)
  6. [Proc inspection](https://forum.nim-lang.org/t/9127)
  7. etc ‚Ä¶ Please use the forum search bar with specific keywords like `macro`, `metaprogramming`, `generics`, `template`, ‚Ä¶

Last but no least, there are three Nim books:
  1. [Nim In Action, ed. Manning](https://book.picheta.me) and [github repo](https://github.com/dom96/nim-in-action-code)
  2. [Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator](https://www.amazon.fr/dp/B0B4R7B9YX).
  3. [Nim Programming Book, by S.Salewski](https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming)

We can also count many projects that are macro- or template-based:
  1. [genny](https://github.com/treeform/genny) and [benchy](https://github.com/treeform/genny). Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
  In general, treeform projects source code are good Nim references
  2. My favorite DSL : the [neural network domain specific language (DSL) of the tensor library Arraymancer](https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim)
  [mratsim](https://github.com/mratsim/) develops this library, and made [a list of all his DSL](https://forum.nim-lang.org/t/9551#62851) in the forum.
  3. [Jester](https://github.com/dom96/jester) library is a HTML DSL, where each block defines a route in your web application.
  4. [nimib](https://pietroppeter.github.io/nimib/) with which this blog post has been written.
  5. [Nim4UE](https://github.com/jmgomez/NimForUE). You can develop Nim code for the Unreal Engine 5 game engine. The macro system parses your procs and outputs DLL for UE.
&quot;&quot;&quot;</span>
nbSave
</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>