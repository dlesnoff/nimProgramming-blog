<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>macroTutorial_fr.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="nimib 0.3.12" name="generator">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/light.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/atom-one-light.css'>
    <script src="https://cdn.jsdelivr.net/gh/pietroppeter/nimib@main/assets/highlight.min.js"></script>
<script>hljs.highlightAll();</script>

  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
pre > code {
  font-size: 1.2em;
}
.nb-output {
  line-height: 1.15;
}
figure {
  margin: 2rem 0;
}
figcaption {
  text-align: center;
}
  
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href=".">üè°</a></span>
  <span><code>macroTutorial_fr.nim</code></span>
  <span><a href="https://github.com/dlesnoff/nimMacros.github.io"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle;" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59c.4.07.55-.17.55-.38c0-.19-.01-.82-.01-1.49c-2.01.37-2.53-.49-2.69-.94c-.09-.23-.48-.94-.82-1.13c-.28-.15-.68-.52-.01-.53c.63-.01 1.08.58 1.23.82c.72 1.21 1.87.87 2.33.66c.07-.52.28-.87.51-1.07c-1.78-.2-3.64-.89-3.64-3.95c0-.87.31-1.59.82-2.15c-.08-.2-.36-1.02.08-2.12c0 0 .67-.21 2.2.82c.64-.18 1.32-.27 2-.27c.68 0 1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82c.44 1.1.16 1.92.08 2.12c.51.56.82 1.27.82 2.15c0 3.07-1.87 3.75-3.65 3.95c.29.25.54.73.54 1.48c0 1.07-.01 1.93-.01 2.2c0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill="#000"></path></svg></a></span>
</div>
<hr>
</header><main>
<h1 style="text-align: center;">Les macros avec Nim - tutoriel de m√©taprogrammation</h1>
<p>Ce tutoriel a pour objectif d'√™tre une introduction aux capacit√©s de m√©taprogrammation du langage de programmation Nim. Il vise √† donner autant de d√©tails que possible pour d√©marrer vos projets.
Il existe de nombreuses ressources que ce soit √† travers les livres ou sur Internet mais vous devriez trouvez ici (√† terme) une description compl√®te du processus de d√©veloppement de macros.</p>
<h3>Plan:</h3>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#proc√©dures-g√©n√©riques">Proc√©dures G√©n√©riques</a></li>
<li><a href="#templates">Templates</a></li>
<li><a href="#macros">Macros</a></li>
<li><a href="#exemple-d‚Äôutilisation">Exemple d‚Äôutilisation</a></li>
<li><a href="#autre-macro-:-`power2enum`">Autre macro : <code>power2Enum</code></a></li>
<li><a href="#r√©f√©rences-et-bibliographie">R√©f√©rences et bibliographie</a></li>
</ol>
<p><a name = "introduction"></a></p>
<h2>Introduction</h2>
<hr />
<blockquote>
<p>Qu'est-ce que la m√©taprogrammation ?</p>
</blockquote>
<p>La m√©taprogrammation consiste √† programmer du code informatique. Autrement dit, l'entr√©e et la sortie de programmes r√©alisant de la m√©taprogrammation seront eux-m√™mes des bouts de code.</p>
<blockquote>
<p>Mon language pr√©f√©r√© ne me permet pas d'√©crire des macros. Pourquoi √©crire des macros (avec Nim)?</p>
</blockquote>
<p>Le principal objectif est d'√©crire facilement des longues portions de code qui sont r√©p√©titives ou pour s'adapter par exemple √† de nombreuses architectures.
Il est √©galement possible d'√©crire de mini-langages de programmation nomm√©s DSL (&quot;domain-specific languages&quot;) pour une utilisation pr√©cise, comme la description de contenu d'une fen√™tre graphique avec <code>Owlkettle</code>
ou pour sp√©cifier les param√®tres d'un r√©seau de neurones <code>Arraymancer</code>. Les macros sont √©crites une fois par le d√©veloppeur d'une biblioth√®que, et les utilisateurs de cette biblioth√®que vont voir leur code modifi√©
par les macros sans m√™me utiliser de macros par eux-m√™mes.</p>
<blockquote>
<p>Quel rapport avec les macros ?</p>
</blockquote>
<p>Les macros sont ces fonctions qui vont travailler sur des bouts de code et g√©n√©rer du code en sortie. Nous verrons par la suite que ce code est repr√©sent√©
sous la forme d'arbre syntaxique nomm√© AST.</p>
<h3>Quatre niveaux d'abstraction</h3>
<p>Il existe quatre niveaux d'abstraction en m√©taprogrammation qui sont chacun associ√©s √† un type de proc√©dure ou it√©rateur:</p>
<ol start="0">
<li>Proc√©dures/fonctions/it√©rateurs ordinaires (Pas de m√©taprogrammation)</li>
<li>Les proc√©dures g√©n√©riques et les classes de type (M√©taprogrammation au niveau du type)</li>
<li>Les ¬´ mod√®les ¬ª <code>template</code> en anglais (Un m√©chanisme de copier-coller avanc√©)</li>
<li>Les <code>Macro</code>s (Substitution d'arbre syntaxique <code>AST</code>)</li>
</ol>
<p>Il faut garder en t√™te que la m√©taprogrammation est un m√©chanisme complexe, et il est fortement recommand√© d'utiliser le niveau d'abstraction le plus faible possible,
et pas de m√©taprogrammation du tout lorsque cela est possible. Il existe plusieurs raisons √† cela. Premi√®rement, il est difficile de relire du code source utilisant de la
m√©taprogrammation. Cela demande beaucoup de temps pour v√©rifier que le code source ne g√©n√®re pas d'erreur et trouver l'origine d'une erreur s'il y en a une.
Sans commentaire, une macro est presque illisible. Vous verrez par la suite qu'il est difficile de comprendre l'objectif et le fonctionnement d'une macro rien qu'en la lisant.
Deuxi√®mement, il est difficile de faire de la gestion d'exception lorsqu'on manipule du code source. Il faut v√©rifier le code source qu'on re√ßoit en entr√©e d'une macro, et comme
les possibilit√©s sont tr√®s nombreuses, il est presque impossible de trier des codes sources valides en entr√©e d'une macro. Cela pose des probl√©matiques de s√©curit√© √©videntes. C'est une des raisons
pour laquelle la plupart des langages de programmation ont √©vit√© d'introduire des capacit√©s de m√©taprogrammation. Enfin, les temps de compilation sont proportionnels au travail que doit r√©aliser le
compilateur. Plus le niveau de m√©taprogrammation est avanc√©, plus le temps de compilation augmente, rendant le d√©veloppement plus complexe et for√ßant ainsi la fragmentation du code en plusieurs modules.</p>
<p>Je vous propose dans ce tutoriel une pr√©sentation de ces quatre niveaux de m√©taprogrammation. Nous verrons au passage des notions n√©cessaires au d√©veloppement de macros, comme les param√®tres non typ√©s,
l'hygi√©nisation des variables, l'introspection de code, les arbres syntaxiques. En bonus, nous verrons des bouts de code (¬´ snippets ¬ª en anglais) qui vous seront peut-√™tre utiles en dehors de la m√©taprogrammation.
Avant d'aborder les macros et les arbres syntaxiques, nous commen√ßons donc avec les proc√©dures g√©n√©riques, puis les mod√®les avec les param√®tres non typ√©s.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/macros</code></pre>
<p><a name = "proc√©dures-g√©n√©riques"></a></p>
<h2>Proc√©dures G√©n√©riques</h2>
<hr />
<p>Un des objectifs de la programmation est l'automatisation de t√¢ches r√©p√©titives.
Certains programmes sont fastidieux √† √©crire et nous √©crivons souvent des codes similaires.</p>
<p>Imaginez que vous voulez programmer une addition. Votre algorithme est probablement g√©n√©ral et ne d√©pend peut-√™tre pas du type de l'entr√©e. Votre algorithme pourrait recevoir
aussi bien des entiers que des nombres flottants en entr√©e.</p>
<p>Vous ne voulez pas r√©√©crire chacun de vos algorithmes pour chacun des types qui conviendraient.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># What to not do!</span>
<span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =
  <span class="hljs-keyword">return</span> x + y

<span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">float</span>): <span class="hljs-built_in">float</span> =
  <span class="hljs-keyword">return</span> x + y

<span class="hljs-keyword">echo</span> add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
<span class="hljs-keyword">echo</span> add(<span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span>)</code></pre><pre class="nb-output">5
8.2</pre>
<p>En effet, que se passerait-il si vous vouliez ajouter une fonction pour un autre type comme <code>int32</code> ou <code>float16</code>?
Vous devrez alors copier-coller votre fonction et changer le type. Bien que cela semble anodin, cela se r√©v√®le vite probl√©matique lorsque vous trouvez un bug dans l'algorithme.</p>
<p>Il vous faut alors corriger autant de fonctions que de types support√©s. De plus, le code devient peu lisible, puisque chaque fonction appara√Æt de nombreuses fois.</p>
<p>Une premi√®re solution consiste √† utiliser les types ¬´ g√©n√©riques implicites ¬ª. On utilise le mot-cl√© <code>or</code> comme pour une expression bool√©enne avec les types qui conviendraient.
Durant la phase de compilation, le compilateur Nim choisit quel type convient √† la situation.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> add(x,y: (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>)): (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>) =
  <span class="hljs-keyword">return</span> x + y

add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span></code></pre>
<p>Il se peut que vous ne sachiez pas vraiment √† l'avance combien de types exactement pourraient √™tre utilis√©s pour votre algorithme.
Vous voudriez peut-√™tre faire des modifications pour certains types pr√©cis. Il convient alors d'utiliser un type g√©n√©rique (non implicite).
Il s'agit d'un type repr√©sent√© par une variable. Par convention, on d√©signe cette variable par une lettre majuscule qui est souvent T, U, V, etc ‚Ä¶</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> add[<span class="hljs-type">T</span>](x,y: <span class="hljs-type">T</span>): <span class="hljs-type">T</span> =
  <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
    x = x.parseFloat()
    y = y.parseFloat()
  <span class="hljs-keyword">var</span> c = x + y
  <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
    <span class="hljs-keyword">return</span> $c
  <span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">return</span> c

add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span>
add <span class="hljs-string">&quot;3.7&quot;</span>, <span class="hljs-string">&quot;4.5&quot;</span></code></pre>
<p><a name = "templates"></a></p>
<h2>Templates</h2>
<hr />
<p>‚ö†Ô∏è Afin d'ex√©cuter chaque code dans la suite de ce tutoriel, vous devrez importer le paquet <code>std/macros</code>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">import</span> std/macros</code></pre>
<p>Nous pouvons voir les <em>templates</em> comme des proc√©dures qui font de la substitution de code, comme un couper-coller qui serait r√©alis√© √† la compilation.</p>
<p>Les proc√©dures <code>templates</code> re√ßoivent g√©n√©ralement en dernier param√®tre un bout de code.
Le type qui correspond √† un bout de code est <code>untyped</code>.
Comme nous souhaitons que le template retourne un bout de code, le type de retour est <code>untyped</code> pour presque tous les cas d'usage.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">## Exemple provenant de std/manual</span>
<span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-keyword">not</span> (a == b)

doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>) <span class="hljs-comment"># Appelle le template `!=` d√©finit ci-dessus.</span></code></pre>
<p>Le langage d√©finit l'op√©rateur bool√©en <code>!=</code> exactement comme ci-dessus. Le code source de Nim avec cet exemple est consultable librement √† <a href="https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped">cette addresse</a>.</p>
<p>On peut facilement dupliquer du code √† l'aide d'un bloc personnalis√©. Attention, on ex√©cute deux fois de suite l'instruction, et donc on ne peux donc pas placer d'affectation en-dessous de ce
template.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
  statements <span class="hljs-comment"># statements est remplac√© par `echo 5` lors de l'appel</span>
  statements

duplicate: <span class="hljs-comment"># A template can receive its last argument as a code</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span></code></pre><pre class="nb-output">5
5</pre>
<p>Ci-dessous, on g√©n√©ralise l'id√©e pour r√©p√©ter le code autant de fois que d√©sir√©.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">## Exemple provenant de Nim In Action de Dominik Picheta</span>
<span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep

<span class="hljs-comment"># On garde les instructions en second argument</span>
<span class="hljs-keyword">template</span> repetition(compteur: <span class="hljs-built_in">int</span>, instructions: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; compteur:
    instructions

repetition <span class="hljs-number">5</span>:
  <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Salut. Je vais dormir 100 millisecondes!&quot;</span>)
  sleep(<span class="hljs-number">100</span>)

<span class="hljs-comment">## Le code est remplac√© par:</span>
<span class="hljs-comment">## for i in 0 ..&lt; 5:</span>
<span class="hljs-comment">##   echo(&quot;Salut. Je vais dormir 100 millisecondes!&quot;)</span>
<span class="hljs-comment">##   sleep(100)</span></code></pre><pre class="nb-output">Salut. Je vais dormir 100 millisecondes!
Salut. Je vais dormir 100 millisecondes!
Salut. Je vais dormir 100 millisecondes!
Salut. Je vais dormir 100 millisecondes!
Salut. Je vais dormir 100 millisecondes!</pre>
<h4>Le mot-cl√© Do-While</h4>
<p>Nim poss√®de peu de mots-cl√©s et de m√©chanismes de flots de contr√¥le, afin de garder le langage simple √† appr√©hender. Cependant, on peut toujours d√©finir un mot-cl√© <code>doWhile</code> que l'on retrouve dans d'autres langages comme <code>C</code> ou <code>Javascript</code>.
Ce mot-cl√© est quasiment identique √† la boucle <code>While</code>, √† l'exception pr√®s qu'elle teste la condition apr√®s le bloc d'instruction. Cela permet de toujours ex√©cuter au-moins une fois le bloc d'instruction.</p>
<p>Par exemple, ce code C affiche <code>Hello World</code> au moins une fois, ind√©pendamment de la valeur de d√©part de la variable <code>i</code>.</p>
<pre><code class="language-cpp">int i = 10; // On doit d√©clarer une variable pour la boucle
do{
  printf(&quot;Hello World\n&quot;);
  i += 1;
}while(i &lt; 10); // do{}while; est une unique instruction
// sur plusieurs lignes, d'o√π le point-virgule √† la fin
</code></pre>
<p>Nous allons recr√©er ce code C avec Nim. Techniquement, nous allons nous servir d'une boucle while pour construire la boucle do-while.
Nous ne pourrons cependant pas obtenir la m√™me syntaxe qu'en C, o√π la condition est affich√©e √† la fin du bloc d'instruction.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
  loop
  <span class="hljs-keyword">while</span> conditional:
    loop

<span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>
doWhile i &lt; <span class="hljs-number">10</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span>
    i.inc

<span class="hljs-comment">## Le template modifie le code pour que soit ex√©cut√©:</span>
<span class="hljs-comment">## echo &quot;Hello World&quot;</span>
<span class="hljs-comment">## i.inc</span>
<span class="hljs-comment">## while i &lt; 10:</span>
<span class="hljs-comment">##   echo &quot;Hello World&quot;</span>
<span class="hljs-comment">##   i.inc</span>
<span class="hljs-comment">##</span>
<span class="hljs-comment">## Ceci est strictement √©quivalent au code C pr√©sent√© ci-dessous.</span></code></pre><pre class="nb-output">Hello World</pre>
<p>Vous noterez cependant que <em>syntaxiquement</em> le code source qu'il est alors permis d'√©crire est diff√©rent du code C++.</p>
<p>En effet, dans le code source C, apparaissent dans l'ordre:</p>
<ol>
<li>le mot-cl√© <code>do</code></li>
<li>le bloc d'instruction</li>
<li>le mot-cl√© <code>while</code></li>
<li>la condition (expression bool√©enne)</li>
</ol>
<p>Avec Nim, on a dans cet ordre:
In Nim, we have in this order:</p>
<ol>
<li>le mot-cl√© <code>doWhile</code></li>
<li>la condition</li>
<li>le bloc d'instruction</li>
</ol>
<p>Nous ne pouvons pas modifier la syntaxe de Nim pour correspondre √† la syntaxe du C.</p>
<h4>√âvaluer le temps d'ex√©cution</h4>
<p>Pour √©valuer le temps d'ex√©cution d'un bout de code, on r√©cup√®re l'heure avant et apr√®s l'ex√©cution, et on affiche la diff√©rence.
Avec Nim, on utilise la fonction <code>getMonoTime</code>.
Plut√¥t que d'√©crire quatre lignes suppl√©mentaires pour chaque bout de code dont on veut mesurer le temps d'ex√©cution, il nous suffit d'√©crire
le template suivant:</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment">## √âvaluation du temps d'ex√©cution</span>
<span class="hljs-keyword">import</span> std/[times, monotimes] <span class="hljs-comment"># times permet un affichage plus lisible d'un `MonoTime`</span>

<span class="hljs-keyword">template</span> benchmark(nomBenchmark: <span class="hljs-built_in">string</span>, code: <span class="hljs-built_in">untyped</span>) =
  <span class="hljs-keyword">block</span>:
    <span class="hljs-keyword">let</span> t0 = getMonoTime() <span class="hljs-comment"># https://nim-lang.org/docs/monotimes.html#getMonoTime</span>
    code
    <span class="hljs-keyword">let</span> √©coul√© = getMonoTime() - t0
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, nomBenchmark, <span class="hljs-string">&quot;] &quot;</span>, √©coul√©

benchmark <span class="hljs-string">&quot;test1&quot;</span>: <span class="hljs-comment"># Devrait retourner une valeur proche de 100 ms</span>
  sleep(<span class="hljs-number">100</span>)</code></pre><pre class="nb-output">CPU Time [test1] 100 milliseconds, 216 microseconds, and 192 nanoseconds</pre>
<p>Le code qui est indent√© en-dessous du bloc <code>benchmark</code> sera d√©limit√© par le code du benchmark.</p>
<p>Puisque la substitution du code est r√©alis√©e au moment de la compilation, cette transformation ne modifie pas les temps obtenus.</p>
<p>Exercice:
Modifier le code pr√©c√©dent pour effectuer une moyenne des temps obtenus apr√®s autant de r√©p√©titions que demander par l'utilisateur.</p>
<p><a name = "macros"></a></p>
<h2>Macros</h2>
<hr />
<p>Les Templates utilisent les param√®tres <code>untyped</code> comme des briques de LEGO¬©, c'est-√†-dire comme du code indivisible qui ne peut-√™tre inspect√© pour ses propri√©t√©s.
Si par exemple, nous ne voulions pas que l'utilisateur de notre template passe en argument un code contenant des d√©clarations, nous ne pourrions le v√©rifier avec un template.
L'utilisateur obtiendrait alors une erreur due √† son mauvais usage de la fonction sans que nous puissions faire quelque chose pour l'en emp√™cher.</p>
<p>Les <code>macro</code>s sont en quelque sorte des <code>template</code> am√©lior√©es qui peuvent analyser le code qu'elles re√ßoivent en argument.</p>
<p>¬´ Tandis que les templates remplacent du code, les macros r√©alisent une introspection. ¬ª</p>
<p>Ici, une introspection de code signifie en analyser le contenu: pr√©sence de d√©finitions, analyser les types utilis√©s, etc‚Ä¶</p>
<p>Au-del√†, de l'introspection, les <code>macro</code>s vont pouvoir retourner une version modifi√©e du code pass√© en argument en injectant des variables dans le code original.</p>
<p>En premier exemple de <code>macro</code>, j'ai choisi la macro la plus simple possible puisqu'elle ne retourne rien, ou plus pr√©cis√©ment, une liste vide d'instructions.
Le code qui lui est pass√© en argument provoquerait une boucle infinie si ex√©cut√©. Heureusement, le code g√©n√©r√© par la macro √©tant vide, rien n'est ex√©cut√©.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> jetteAuxOubliettes(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-literal">result</span> = newStmtList()

jetteAuxOubliettes:
  <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Si tu ne fais rien, je te spammerai ind√©finiment !&quot;</span></code></pre>
<h3>Arbre syntaxique abstrait</h3>
<p>Un arbre syntaxique (abstrait) (en anglais AST pour &quot;abstract syntaxic tree&quot;) est une repr√©sentation du code interne au compilateur, qui est dite interm√©diaire, car elle repr√©sente le code entre le code source (compr√©hensible par un humain) et le code g√©n√©r√© (difficilement compr√©hensible par un humain mais pour un compilateur: code C, C++, Objective-C, ou Javascript selon le <code>backend</code>).</p>
<p>Chaque code source Nim a son √©quivalent en AST. En revanche plusieurs codes sources peuvent correspondre √† un AST.</p>
<p>Les commentaires et espaces du code source sont supprim√©s.</p>
<p>L'arbre syntaxique repr√©sente le code source sous la forme d'une arborescence ordonn√©e. L'AST est form√©e de n≈ìuds qui poss√®dent chacun un ou plusieurs n≈ìuds enfants. Ces n≈ìuds ne peuvent √™tre intervertis sans changer le sens du code.</p>
<p>Pour obtenir une repr√©sentation du code syntaxique d'un code, on peut √©crire ce code sous une <code>macro</code> sp√©ciale appel√©e <code>dumpTree</code>.</p>
<h3>AST Manipulation</h3>
<p>In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST). To get a representation of the AST corresponding to a code, we can use the <code>macro</code> <code>dumpTree</code>.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># N'oubliez pas d'importer std/macros!</span>
<span class="hljs-comment"># Vous pouvez utiliser --hints:off pour mieux discerner l'Arbre syntaxique</span>
dumpTree:
  <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Salut!&quot;</span></code></pre>
<p>Vous trouverez dans la sortie du compilateur l'AST suivant:</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    StrLit &quot;Salut!&quot;
</code></pre>
<p>Ce code contient quatre n≈ìuds. <code>StmtList</code> est √† la racine de l'arbre, puis chaque indentation d√©signe que l'on passe √† un n≈ìud enfant, √† un niveau inf√©rieur dans la hi√©rarchie.</p>
<p><code>StmtList</code> est la contraction de <em>statements list</em> qui signifie bloc d'instructions. Il rassemble ensemble toutes les instructions dans le bloc.</p>
<p>Le n≈ìud suivant <code>Command</code> indique que l'on utilise une proc√©dure dont le nom est donn√© par son n≈ìud enfant <code>Ident</code>. Un <code>Ident</code> peut-√™tre le nom d'une variable, d'un objet ou d'une proc√©dure.
Le n≈ìud <code>Command</code> pr√©cise la fa√ßon dont la proc√©dure est appel√©e. Je ne d√©taille pas ici, mais cela a un rapport avec l'UFCS: Uniform Function Call Syntax qui est une propri√©t√© du langage qui indique qu'une fonction ou proc√©dure peut √™tre appel√©e indiff√©remment avec trois syntaxes distinctes.</p>
<p>Nous avons ensuite deux n≈ìuds avec du texte accol√© √† la suite. Les n≈ìuds correspondants √† des noms de variables ou de proc√©dures sont des n≈ìuds de type <code>Ident</code>.
Les chaines de caract√®res sont des n≈ìuds de type <code>StrLit</code>.</p>
<p>Afin de vous donner une id√©e de ce qui se passe en g√©n√©ral, voici un exemple d'un code nettement plus complexe.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-comment"># Don't forget to import std/macros!</span>
<span class="hljs-comment"># You can use --hints:off to display only the AST tree</span>
dumpTree:
  <span class="hljs-keyword">type</span>
    myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      left: <span class="hljs-built_in">seq</span>[myObject]
      right: <span class="hljs-built_in">seq</span>[myObject]</code></pre>
<p>Ce code donne en sortie l'arbre syntaxique suivant:</p>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
</code></pre>
<p>L'AST retourn√© par <code>dumpTree</code> d√©marrera sauf quelques exceptions toujours par <code>StmtList</code>.
Les d√©finitions de type se retrouvent toujours dans une <code>TypeSection</code> qui poss√®dent autant d'enfants de type <code>TypeDef</code> que de d√©finitions.
Les types objets sont d√©finis par des <code>ObjectTy</code>.</p>
<p>Afin de mieux visualiser l'hi√©rarchie, vous trouverez ci-dessous un sch√©ma de l'AST:</p>
<figure>
<img src="./pictures/ASTtree.jpg" alt="Arbre syntaxique de la d√©finition du type myObject">
<figcaption>Arbre syntaxique de la d√©finition du type myObject</figcaption>
</figure>
<p>Il n'est pas n√©cessaire que vous compreniez l'ensemble de la g√©n√©ration de l'AST. Sachez simplement que vous pouvez l'obtenir avec la commande <code>DumpTree</code>.
Si jamais vous avez besoin d'√©crire vous m√™me un AST pour une macro, sachez que des exemples pour toutes les structures et mots-clefs sont dans la documentation des macros:
<a href="https://nim-lang.org/docs/macros.html">std/macros</a></p>
<h3>Premier exemple de Macro: multiplication par deux</h3>
<p>La premi√®re macro que je vous pr√©sente provient de cette <a href="https://www.youtube.com/watch?v=WHyOHQ_GkNo">vid√©o Youtube</a> r√©alis√©e par <a href="https://www.youtube.com/c/Fireship">Jeff Delaunay sur sa cha√Æne Fireship</a>.</p>
<p>Lorsque un utilisateur d√©sire afficher des valeurs enti√®res sous cette macro, les valeurs seront multipli√©es par deux.</p>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> timesTwo(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-literal">result</span> = statements
  <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
      <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
        node.intVal = node.intVal*<span class="hljs-number">2</span>
timesTwo:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span></code></pre><pre class="nb-output">2
4
6</pre>
<p>Avant d'expliciter le fonctionnement de la macro, on va comparer l'AST du code donn√© en entr√©e,
avec celui que l'on pense obtenir avec le code:</p>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span>
dumpTree:
  <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">4</span>
  <span class="hljs-keyword">echo</span> <span class="hljs-number">6</span></code></pre>
<p>Le compilateur retourne:</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 3
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
</code></pre>
<p>Cette sortie ressemble √† s'y m√©prendre au premier exemple d'AST vu pr√©c√©demment.
Au lieu du StrLit &quot;Salut!&quot;, on a d√©sormais IntLit suivi du nombre pr√©sent dans le code source ou dans la sortie.</p>
<p>En compilant ce code, vous obtiendrez l‚ÄôAST correspondant. Cet AST simple est compos√© de quatre n≈ìuds :</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
</code></pre>
<p><code>StmtList</code> signifie <em>liste d‚Äôinstructions</em>. Il regroupe toutes les instructions de votre bloc.</p>
<p>Le n≈ìud <code>Command</code> indique que vous utilisez une fonction dont le nom est donn√© par son n≈ìud enfant <code>Ident</code>. Un <code>Ident</code> peut √™tre n‚Äôimporte quel nom de variable, d‚Äôobjet ou de proc√©dure.</p>
<p>Notre litt√©ral entier dont la valeur est 1 poss√®de le type de n≈ìud <code>IntLit</code>.</p>
<p>Remarquez que l‚Äôordre des n≈ìuds dans l‚ÄôAST est crucial. Si nous inversons les deux derniers n≈ìuds, nous obtiendrions l‚ÄôAST du code <code>1 echo</code>, qui ne compile pas.</p>
<pre><code class="language-nim">StmtList
  Command
    IntLit 1
    Ident &quot;echo&quot;
</code></pre>
<p><code>StmtList</code>, <code>Command</code>, <code>IntLit</code> et <code>Ident</code> sont les NodeKind de l‚ÄôAST du code. √Ä l‚Äôint√©rieur d‚Äôune macro, ils sont nomm√©s avec le pr√©fixe <code>nnk</code>, par exemple : <code>nnkIdent</code>.</p>
<p>Vous pouvez obtenir la liste compl√®te des node kinds dans le <a href="https://github.com/nim-lang/Nim/blob/a8c6e36323601a64dcb6947a694f0bde97b632b2/lib/core/macros.nim#L25-L89">code source de std/macros</a>.</p>
<h2>Premier exemple de macro</h2>
<p>La sortie d‚Äôune macro est un AST. Voici ce qu‚Äôon obtient pour un exemple simple :</p>
<pre><code class="language-nim">StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
</code></pre>
<p>Les retours √† la ligne ne font pas partie de l‚ÄôAST !</p>
<p>Ici, l‚ÄôAST de sortie est presque identique √† l‚Äôentr√©e. Seule la valeur des litt√©raux entiers change.</p>
<p>Le n≈ìud racine est une liste d‚Äôinstructions. Pour acc√©der √† ses √©l√©ments, on utilise l‚Äôindexation : <code>statements[0]</code>.</p>
<p>Pour parcourir tous ses enfants : <code>for statement in statements</code>.</p>
<p>Nous devons r√©cup√©rer les n≈ìuds situ√©s sous une instruction <code>Command</code> qui sont des litt√©raux entiers, puis modifier <code>node.intVal</code>.</p>
<h2>Analyse d‚Äôune d√©finition de type</h2>
<p>Nous voulons afficher la repr√©sentation m√©moire d‚Äôun type donn√©. L‚Äôobjectif est de rep√©rer des champs mal align√©s qui cr√©ent des &quot;trous&quot; de m√©moire (padding) dans les objets.</p>
<p>Les processeurs pr√©f√®rent que les adresses soient align√©es sur des puissances de deux. Sinon, ils ins√®rent du padding.</p>
<p>On peut compacter les structures avec <code>{.packed.}</code>, mais cela ralentit les acc√®s m√©moire.</p>
<p>La premi√®re √©tape consiste √† observer l‚ÄôAST d‚Äôune d√©finition de type simple.</p>
<h3>Exemple minimal</h3>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
      a: <span class="hljs-built_in">float32</span></code></pre>
<p>R√©sultat :</p>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      Ident &quot;Thing&quot;
      Empty
      ObjectTy
        Empty
        Empty
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
</code></pre>
<p>Nous augmenterons la complexit√© pour rep√©rer les cas particuliers.</p>
<h2>Exemple avec h√©ritage et pragmas</h2>
<pre><code class="nohighlight hljs nim">dumpTree:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      a: <span class="hljs-built_in">float32</span>
      b: <span class="hljs-built_in">string</span></code></pre>
<p>AST :</p>
<pre><code class="language-nim">StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;Thing&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      ObjectTy
        Empty
        OfInherit
          Ident &quot;RootObj&quot;
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
          IdentDefs
            Ident &quot;b&quot;
            Ident &quot;string&quot;
            Empty
</code></pre>
<p>Notez que le nom du type appara√Æt sous <code>PragmaExpr</code>. Il faudra en tenir compte lors de la lecture de l'arbre que nous allons devoir r√©aliser pour la macro.</p>
<h2>Structure g√©n√©rale d‚Äôune macro</h2>
<p>Une macro suit toujours les m√™mes √©tapes :</p>
<ol>
<li>Chercher un n≈ìud d‚Äôun type particulier dans l‚ÄôAST.</li>
<li>Extraire ses propri√©t√©s.</li>
<li>G√©n√©rer un AST en sortie bas√© sur ces propri√©t√©s.</li>
<li>Continuer √† parcourir l‚ÄôAST.</li>
</ol>
<p>Vos macros auront besoin de commentaires d√©taill√©s pour rester lisibles.</p>
<h2>Macro <code>typeMemoryRepr</code></h2>
<p>Cette macro g√©n√®re automatiquement :</p>
<ul>
<li>la d√©claration du type,</li>
<li>une variable d‚Äôexemple,</li>
<li>l‚Äôaffichage de sa taille et adresse,</li>
<li>l‚Äôaffichage de la taille et adresse de chaque champ.</li>
</ul>
<p>Cela √©vite d‚Äô√©crire manuellement des dizaines de <code>echo var.field.sizeof</code>.</p>
<h3>Construction de fragments AST</h3>
<h4>Affichage de la taille d‚Äôun champ</h4>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> echoSizeVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
  <span class="hljs-comment">## quote do:</span>
  <span class="hljs-comment">##   echo `variable`.`nameOfField`.sizeof</span>
  newStmtList(nnkCommand.newTree(
            newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
            nnkDotExpr.newTree(
              nnkDotExpr.newTree(
                newIdentNode(variable),
                newIdentNode(nameOfField) <span class="hljs-comment"># Nom du champ</span>
                ),
                newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
            )
            ))</code></pre>
<h4>Affichage de l‚Äôadresse d‚Äôun champ</h4>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">proc</span> echoAddressVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
  <span class="hljs-comment">## quote do:</span>
  <span class="hljs-comment">##   echo `variable`.`nameOfField`.addr.repr</span>
  newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    newIdentNode(variable),
                    newIdentNode(nameOfField)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                ),
                newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
              )
              ))</code></pre>
<h3>Macro compl√®te</h3>
<pre><code class="nohighlight hljs nim"><span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
  <span class="hljs-comment">## Cette macro :</span>
  <span class="hljs-comment">## * d√©finit le type</span>
  <span class="hljs-comment">## * cr√©e une variable de ce type</span>
  <span class="hljs-comment">## * affiche sa taille et son adresse</span>
  <span class="hljs-comment">## * affiche la taille et l'adresse de chaque champ</span>

  <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
    `typedef`

  <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
    <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
      <span class="hljs-keyword">let</span> typeSection = statement
      <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
        <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
          <span class="hljs-keyword">var</span> tnode = typeSection[i]
          <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

          <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
          <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)

          <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
            quote <span class="hljs-keyword">do</span>:
              <span class="hljs-keyword">var</span> `testVariable`:`nameOfType`
              <span class="hljs-keyword">echo</span> `testVariable`.sizeof
              <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr
          )

          tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]
          <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList

          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoSizeVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))
            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoAddressVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))

  <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr</code></pre>
<p><a name = "exemple-d‚Äôutilisation"></a></p>
<h2>Exemple d‚Äôutilisation</h2>
<hr />
<pre><code class="nohighlight hljs nim">typeMemoryRepr:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
      a: <span class="hljs-built_in">float32</span>
      b: <span class="hljs-built_in">string</span></code></pre><pre class="nb-output">32
ptr Thing(a: 0.0, b: &quot;&quot;)
4
ptr 0.0
16
ptr &quot;&quot;</pre>
<p>Analyser un type soi-m√™me est risqu√© : pragmas, h√©ritages, enums, alias, types cycliques, objets <code>case</code>, etc.
Une fonction d√©di√©e sera pr√©sent√©e dans une future version.</p>
<p><a name = "autre-macro-:-`power2enum`"></a></p>
<h2>Autre macro : <code>power2Enum</code></h2>
<hr />
<p>Cette macro cr√©e automatiquement des enums dont les valeurs sont des puissances de deux.</p>
<pre><code class="language-nim">macro power2Enum(body: untyped): untyped =
  let srcFields = body[^1][1..^1]
  var dstFields =  nnkEnumTy.newTree(newEmptyNode())
  for idx, field in enumerate(srcFields):
    dstFields.add nnkEnumFieldDef.newTree(field, newIntLitNode(pow(2.0, idx.float).int))

  body[^1] = dstFields
  echo repr body
  body
</code></pre>
<p>Usage :</p>
<pre><code class="language-nim">type Test {.power2Enum.}  = enum
  a, b, c, d
</code></pre>
<p>Mais souvent, un simple <code>set</code> + <code>cast</code> suffit.</p>
<p><a name = "r√©f√©rences-et-bibliographie"></a></p>
<h2>R√©f√©rences et bibliographie</h2>
<hr />
<p>Pressez <code>Ctrl</code> en m√™me temps que <code>Clic</code> pour ouvrir les liens dans un nouvel onglet.</p>
<p>D'abord, quatre ressources officielles du site Nim :</p>
<ol>
<li><a href="https://nim-by-example.github.io/macros/">Nim by Example</a></li>
<li><a href="https://nim-lang.org/docs/tut3.html">Nim Tutorial (Part III)</a></li>
<li><a href="https://nim-lang.org/docs/manual.html#macros">Section du manuel sur les macros</a></li>
<li><a href="https://nim-lang.org/docs/macros.html">Documentation standard de std/macros</a></li>
</ol>
<p>Les documents 2 et 3 sont compl√©mentaires, tandis que le dernier sera votre r√©f√©rence exhaustive √† jour. Il fournit des AST pour tous les n≈ìuds.</p>
<p>De nombreux d√©veloppeurs ont √©crit des tutoriels sur les macros :</p>
<ol>
<li><a href="https://learnxinyminutes.com/docs/nim/">Nim in Y minutes</a></li>
<li><a href="https://dev.to/beef331/demystification-of-macros-in-nim-13n8">Jason Beetham a.k.a ElegantBeef's dev.to tutorial</a>. This tutorial contains a lot of good first examples.</li>
<li><a href="https://www.youtube.com/watch?v=GJpn6SfR_1M">Pattern matching (sadly outdated) in macros by DevOnDuty</a></li>
<li><a href="https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro">Tomohiro's FAQ section about macros</a></li>
<li><a href="https://flyx.org/nimyaml-making-of/">The Making of NimYAML's article of flyx</a></li>
</ol>
<p>Il existe √©galement beaucoup de posts sur le forum qui sont informatifs:</p>
<ol>
<li><a href="https://forum.nim-lang.org/t/2587">What is &quot;Metaprogramming&quot; paradigm used for ?</a></li>
<li><a href="https://forum.nim-lang.org/t/9470">Custom macro inserts macro help</a></li>
<li><a href="https://forum.nim-lang.org/t/9498">See generated code after template processing</a></li>
<li><a href="https://forum.nim-lang.org/t/10037">Fast array assignment</a></li>
<li><a href="https://forum.nim-lang.org/t/10513">Variable injection</a></li>
<li><a href="https://forum.nim-lang.org/t/9127">Proc inspection</a></li>
<li>etc ‚Ä¶ Utiliser la barre de recherche du forum ! mots-cl√©s: <code>macro</code>, <code>metaprogramming</code>, <code>generics</code>, <code>template</code>, ‚Ä¶</li>
</ol>
<p>Enfin, trois livres Nim :</p>
<ol>
<li><a href="https://book.picheta.me">Nim In Action, ed. Manning</a> and <a href="https://github.com/dom96/nim-in-action-code">github repo</a></li>
<li><a href="https://www.amazon.fr/dp/B0B4R7B9YX">Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator</a>.</li>
<li><a href="https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming">Nim Programming Book, by S.Salewski</a></li>
</ol>
<p>De nombreux projets utilisent intensivement des macros ou des templates :</p>
<ol>
<li>
<p><a href="https://github.com/treeform/genny">genny</a> and <a href="https://github.com/treeform/genny">benchy</a>. Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
In general, treeform projects source code are good Nim references</p>
</li>
<li>
<p>Mon DSL favori : the <a href="https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim">neural network domain specific language (DSL) of the tensor library Arraymancer</a>
<a href="https://github.com/mratsim/">mratsim</a> develops this library, and made <a href="https://forum.nim-lang.org/t/9551#62851">a list of all his DSL</a> in the forum.</p>
</li>
<li>
<p><a href="https://github.com/dom96/jester">Jester</a> library is a HTML DSL, where each block defines a route in your web application.</p>
</li>
<li>
<p><a href="https://pietroppeter.github.io/nimib/">nimib</a> with which this blog post has been written.</p>
</li>
<li>
<p><a href="https://github.com/jmgomez/NimForUE">Nim4UE</a>. You can develop Nim code for the Unreal Engine 5 game engine. The macro system parses your procs and outputs DLL for UE.</p>
</li>
</ol>
</main>
<footer>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nohighlight nim hljs"><span class="hljs-keyword">import</span> std/[strutils, macros]
<span class="hljs-keyword">import</span> std/[enumerate, math]
<span class="hljs-keyword">import</span> nimib, nimoji

nbInit

<span class="hljs-comment"># add a ToC</span>
<span class="hljs-keyword">var</span> nbToc: <span class="hljs-type">NbBlock</span>

<span class="hljs-keyword">template</span> addToc =
  newNbBlock(<span class="hljs-string">&quot;nbText&quot;</span>, <span class="hljs-literal">false</span>, nb, nbToc, <span class="hljs-string">&quot;&quot;</span>):
    nbToc.output = <span class="hljs-string">&quot;### Plan:</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

<span class="hljs-keyword">template</span> nbSection(name:<span class="hljs-built_in">string</span>) =
  <span class="hljs-keyword">let</span> anchorName = name.toLower.replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)
  nbText <span class="hljs-string">&quot;&lt;a name = </span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">## &quot;</span> &amp; name &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-meta">\n</span><span class="hljs-string">---&quot;</span>
  <span class="hljs-comment"># see below, but any number works for a numbered list</span>
  nbToc.output.add <span class="hljs-string">&quot;1. &lt;a href=</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">#&quot;</span> &amp; anchorName &amp; <span class="hljs-string">&quot;</span><span class="hljs-meta">\&quot;</span><span class="hljs-string">&gt;&quot;</span> &amp; name &amp; <span class="hljs-string">&quot;&lt;/a&gt;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>

nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
&lt;h1 style=&quot;text-align: center;&quot;&gt;Les macros avec Nim - tutoriel de m√©taprogrammation&lt;/h1&gt;

Ce tutoriel a pour objectif d'√™tre une introduction aux capacit√©s de m√©taprogrammation du langage de programmation Nim. Il vise √† donner autant de d√©tails que possible pour d√©marrer vos projets.
Il existe de nombreuses ressources que ce soit √† travers les livres ou sur Internet mais vous devriez trouvez ici (√† terme) une description compl√®te du processus de d√©veloppement de macros.

&quot;&quot;&quot;</span>

addToc()

nbSection <span class="hljs-string">&quot;Introduction&quot;</span>
nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
&gt; Qu'est-ce que la m√©taprogrammation ?

La m√©taprogrammation consiste √† programmer du code informatique. Autrement dit, l'entr√©e et la sortie de programmes r√©alisant de la m√©taprogrammation seront eux-m√™mes des bouts de code.

&gt; Mon language pr√©f√©r√© ne me permet pas d'√©crire des macros. Pourquoi √©crire des macros (avec Nim)?

Le principal objectif est d'√©crire facilement des longues portions de code qui sont r√©p√©titives ou pour s'adapter par exemple √† de nombreuses architectures.
Il est √©galement possible d'√©crire de mini-langages de programmation nomm√©s DSL (&quot;domain-specific languages&quot;) pour une utilisation pr√©cise, comme la description de contenu d'une fen√™tre graphique avec `Owlkettle`
ou pour sp√©cifier les param√®tres d'un r√©seau de neurones `Arraymancer`. Les macros sont √©crites une fois par le d√©veloppeur d'une biblioth√®que, et les utilisateurs de cette biblioth√®que vont voir leur code modifi√©
par les macros sans m√™me utiliser de macros par eux-m√™mes.

&gt; Quel rapport avec les macros ?

Les macros sont ces fonctions qui vont travailler sur des bouts de code et g√©n√©rer du code en sortie. Nous verrons par la suite que ce code est repr√©sent√©
sous la forme d'arbre syntaxique nomm√© AST.
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">hlMd&quot;&quot;&quot;
### Quatre niveaux d'abstraction
Il existe quatre niveaux d'abstraction en m√©taprogrammation qui sont chacun associ√©s √† un type de proc√©dure ou it√©rateur:

  0. Proc√©dures/fonctions/it√©rateurs ordinaires (Pas de m√©taprogrammation)
  1. Les proc√©dures g√©n√©riques et les classes de type (M√©taprogrammation au niveau du type)
  2. Les ¬´ mod√®les ¬ª `template` en anglais (Un m√©chanisme de copier-coller avanc√©)
  3. Les `Macro`s (Substitution d'arbre syntaxique `AST`)

Il faut garder en t√™te que la m√©taprogrammation est un m√©chanisme complexe, et il est fortement recommand√© d'utiliser le niveau d'abstraction le plus faible possible,
et pas de m√©taprogrammation du tout lorsque cela est possible. Il existe plusieurs raisons √† cela. Premi√®rement, il est difficile de relire du code source utilisant de la
m√©taprogrammation. Cela demande beaucoup de temps pour v√©rifier que le code source ne g√©n√®re pas d'erreur et trouver l'origine d'une erreur s'il y en a une.
Sans commentaire, une macro est presque illisible. Vous verrez par la suite qu'il est difficile de comprendre l'objectif et le fonctionnement d'une macro rien qu'en la lisant.
Deuxi√®mement, il est difficile de faire de la gestion d'exception lorsqu'on manipule du code source. Il faut v√©rifier le code source qu'on re√ßoit en entr√©e d'une macro, et comme
les possibilit√©s sont tr√®s nombreuses, il est presque impossible de trier des codes sources valides en entr√©e d'une macro. Cela pose des probl√©matiques de s√©curit√© √©videntes. C'est une des raisons
pour laquelle la plupart des langages de programmation ont √©vit√© d'introduire des capacit√©s de m√©taprogrammation. Enfin, les temps de compilation sont proportionnels au travail que doit r√©aliser le
compilateur. Plus le niveau de m√©taprogrammation est avanc√©, plus le temps de compilation augmente, rendant le d√©veloppement plus complexe et for√ßant ainsi la fragmentation du code en plusieurs modules.

Je vous propose dans ce tutoriel une pr√©sentation de ces quatre niveaux de m√©taprogrammation. Nous verrons au passage des notions n√©cessaires au d√©veloppement de macros, comme les param√®tres non typ√©s,
l'hygi√©nisation des variables, l'introspection de code, les arbres syntaxiques. En bonus, nous verrons des bouts de code (¬´ snippets ¬ª en anglais) qui vous seront peut-√™tre utiles en dehors de la m√©taprogrammation.
Avant d'aborder les macros et les arbres syntaxiques, nous commen√ßons donc avec les proc√©dures g√©n√©riques, puis les mod√®les avec les param√®tres non typ√©s.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">import</span> std/macros

nbSection <span class="hljs-string">&quot;Proc√©dures G√©n√©riques&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
Un des objectifs de la programmation est l'automatisation de t√¢ches r√©p√©titives.
Certains programmes sont fastidieux √† √©crire et nous √©crivons souvent des codes similaires.

Imaginez que vous voulez programmer une addition. Votre algorithme est probablement g√©n√©ral et ne d√©pend peut-√™tre pas du type de l'entr√©e. Votre algorithme pourrait recevoir
aussi bien des entiers que des nombres flottants en entr√©e.

Vous ne voulez pas r√©√©crire chacun de vos algorithmes pour chacun des types qui conviendraient.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment"># What to not do!</span>
  <span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =
    <span class="hljs-keyword">return</span> x + y

  <span class="hljs-keyword">proc</span> add(x, y: <span class="hljs-built_in">float</span>): <span class="hljs-built_in">float</span> =
    <span class="hljs-keyword">return</span> x + y

  <span class="hljs-keyword">echo</span> add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
  <span class="hljs-keyword">echo</span> add(<span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span>)

nbText:<span class="hljs-string">&quot;&quot;&quot;
En effet, que se passerait-il si vous vouliez ajouter une fonction pour un autre type comme `int32` ou `float16`?
Vous devrez alors copier-coller votre fonction et changer le type. Bien que cela semble anodin, cela se r√©v√®le vite probl√©matique lorsque vous trouvez un bug dans l'algorithme.

Il vous faut alors corriger autant de fonctions que de types support√©s. De plus, le code devient peu lisible, puisque chaque fonction appara√Æt de nombreuses fois.

Une premi√®re solution consiste √† utiliser les types ¬´ g√©n√©riques implicites ¬ª. On utilise le mot-cl√© `or` comme pour une expression bool√©enne avec les types qui conviendraient.
Durant la phase de compilation, le compilateur Nim choisit quel type convient √† la situation.
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">proc</span> add(x,y: (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>)): (<span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">float</span>) =
    <span class="hljs-keyword">return</span> x + y

  add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
  add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Il se peut que vous ne sachiez pas vraiment √† l'avance combien de types exactement pourraient √™tre utilis√©s pour votre algorithme.
Vous voudriez peut-√™tre faire des modifications pour certains types pr√©cis. Il convient alors d'utiliser un type g√©n√©rique (non implicite).
Il s'agit d'un type repr√©sent√© par une variable. Par convention, on d√©signe cette variable par une lettre majuscule qui est souvent T, U, V, etc ‚Ä¶
&quot;&quot;&quot;</span>

nbCodeSkip:
  <span class="hljs-keyword">proc</span> add[<span class="hljs-type">T</span>](x,y: <span class="hljs-type">T</span>): <span class="hljs-type">T</span> =
    <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
      x = x.parseFloat()
      y = y.parseFloat()
    <span class="hljs-keyword">var</span> c = x + y
    <span class="hljs-keyword">when</span> <span class="hljs-type">T</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span>:
      <span class="hljs-keyword">return</span> $c
    <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">return</span> c

  add <span class="hljs-number">2</span>, <span class="hljs-number">3</span> <span class="hljs-comment"># Selects int</span>
  add <span class="hljs-number">3.7</span>, <span class="hljs-number">4.5</span> <span class="hljs-comment"># Selects float</span>
  add <span class="hljs-string">&quot;3.7&quot;</span>, <span class="hljs-string">&quot;4.5&quot;</span>

nbSection <span class="hljs-string">&quot;Templates&quot;</span>
nbText:<span class="hljs-string">&quot;&quot;&quot;
:warning: Afin d'ex√©cuter chaque code dans la suite de ce tutoriel, vous devrez importer le paquet `std/macros`.
&quot;&quot;&quot;</span>.emojize

nbCodeSkip:
  <span class="hljs-keyword">import</span> std/macros

nbText: <span class="hljs-string">&quot;&quot;&quot;
Nous pouvons voir les *templates* comme des proc√©dures qui font de la substitution de code, comme un couper-coller qui serait r√©alis√© √† la compilation.

Les proc√©dures `templates` re√ßoivent g√©n√©ralement en dernier param√®tre un bout de code.
Le type qui correspond √† un bout de code est `untyped`.
Comme nous souhaitons que le template retourne un bout de code, le type de retour est `untyped` pour presque tous les cas d'usage.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment">## Exemple provenant de std/manual</span>
  <span class="hljs-keyword">template</span> `!=` (a, b: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-keyword">not</span> (a == b)

  doAssert(<span class="hljs-number">4</span> != <span class="hljs-number">5</span>) <span class="hljs-comment"># Appelle le template `!=` d√©finit ci-dessus.</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
Le langage d√©finit l'op√©rateur bool√©en `!=` exactement comme ci-dessus. Le code source de Nim avec cet exemple est consultable librement √† [cette addresse](https://nim-lang.org/docs/system.html#%21%3D.t%2Cuntyped%2Cuntyped).
&quot;&quot;&quot;</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
On peut facilement dupliquer du code √† l'aide d'un bloc personnalis√©. Attention, on ex√©cute deux fois de suite l'instruction, et donc on ne peux donc pas placer d'affectation en-dessous de ce
template.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">template</span> duplicate(statements: <span class="hljs-built_in">untyped</span>) =
    statements <span class="hljs-comment"># statements est remplac√© par `echo 5` lors de l'appel</span>
    statements

  duplicate: <span class="hljs-comment"># A template can receive its last argument as a code</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">5</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
Ci-dessous, on g√©n√©ralise l'id√©e pour r√©p√©ter le code autant de fois que d√©sir√©.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment">## Exemple provenant de Nim In Action de Dominik Picheta</span>
  <span class="hljs-keyword">from</span> std/os <span class="hljs-keyword">import</span> sleep

  <span class="hljs-comment"># On garde les instructions en second argument</span>
  <span class="hljs-keyword">template</span> repetition(compteur: <span class="hljs-built_in">int</span>, instructions: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; compteur:
      instructions

  repetition <span class="hljs-number">5</span>:
    <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;Salut. Je vais dormir 100 millisecondes!&quot;</span>)
    sleep(<span class="hljs-number">100</span>)

  <span class="hljs-comment">## Le code est remplac√© par:</span>
  <span class="hljs-comment">## for i in 0 ..&lt; 5:</span>
  <span class="hljs-comment">##   echo(&quot;Salut. Je vais dormir 100 millisecondes!&quot;)</span>
  <span class="hljs-comment">##   sleep(100)</span>

nbText: <span class="hljs-string">&quot;&quot;&quot;
#### Le mot-cl√© Do-While
Nim poss√®de peu de mots-cl√©s et de m√©chanismes de flots de contr√¥le, afin de garder le langage simple √† appr√©hender. Cependant, on peut toujours d√©finir un mot-cl√© `doWhile` que l'on retrouve dans d'autres langages comme `C` ou `Javascript`.
Ce mot-cl√© est quasiment identique √† la boucle `While`, √† l'exception pr√®s qu'elle teste la condition apr√®s le bloc d'instruction. Cela permet de toujours ex√©cuter au-moins une fois le bloc d'instruction.

Par exemple, ce code C affiche `Hello World` au moins une fois, ind√©pendamment de la valeur de d√©part de la variable `i`.
```cpp
int i = 10; // On doit d√©clarer une variable pour la boucle
do{
  printf(&quot;Hello World\n&quot;);
  i += 1;
}while(i &lt; 10); // do{}while; est une unique instruction
// sur plusieurs lignes, d'o√π le point-virgule √† la fin
```
Nous allons recr√©er ce code C avec Nim. Techniquement, nous allons nous servir d'une boucle while pour construire la boucle do-while.
Nous ne pourrons cependant pas obtenir la m√™me syntaxe qu'en C, o√π la condition est affich√©e √† la fin du bloc d'instruction.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">template</span> doWhile(conditional, loop: <span class="hljs-built_in">untyped</span>) =
    loop
    <span class="hljs-keyword">while</span> conditional:
      loop

  <span class="hljs-keyword">var</span> i = <span class="hljs-number">10</span>
  doWhile i &lt; <span class="hljs-number">10</span>:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span>
      i.inc

  <span class="hljs-comment">## Le template modifie le code pour que soit ex√©cut√©:</span>
  <span class="hljs-comment">## echo &quot;Hello World&quot;</span>
  <span class="hljs-comment">## i.inc</span>
  <span class="hljs-comment">## while i &lt; 10:</span>
  <span class="hljs-comment">##   echo &quot;Hello World&quot;</span>
  <span class="hljs-comment">##   i.inc</span>
  <span class="hljs-comment">##</span>
  <span class="hljs-comment">## Ceci est strictement √©quivalent au code C pr√©sent√© ci-dessous.</span>

nbText:<span class="hljs-string">hlMd&quot;&quot;&quot;
Vous noterez cependant que _syntaxiquement_ le code source qu'il est alors permis d'√©crire est diff√©rent du code C++.

En effet, dans le code source C, apparaissent dans l'ordre:
  1. le mot-cl√© `do`
  2. le bloc d'instruction
  3. le mot-cl√© `while`
  4. la condition (expression bool√©enne)

Avec Nim, on a dans cet ordre:
In Nim, we have in this order:
  1. le mot-cl√© `doWhile`
  2. la condition
  3. le bloc d'instruction

Nous ne pouvons pas modifier la syntaxe de Nim pour correspondre √† la syntaxe du C.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
#### √âvaluer le temps d'ex√©cution
Pour √©valuer le temps d'ex√©cution d'un bout de code, on r√©cup√®re l'heure avant et apr√®s l'ex√©cution, et on affiche la diff√©rence.
Avec Nim, on utilise la fonction `getMonoTime`.
Plut√¥t que d'√©crire quatre lignes suppl√©mentaires pour chaque bout de code dont on veut mesurer le temps d'ex√©cution, il nous suffit d'√©crire
le template suivant:
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment">## √âvaluation du temps d'ex√©cution</span>
  <span class="hljs-keyword">import</span> std/[times, monotimes] <span class="hljs-comment"># times permet un affichage plus lisible d'un `MonoTime`</span>

  <span class="hljs-keyword">template</span> benchmark(nomBenchmark: <span class="hljs-built_in">string</span>, code: <span class="hljs-built_in">untyped</span>) =
    <span class="hljs-keyword">block</span>:
      <span class="hljs-keyword">let</span> t0 = getMonoTime() <span class="hljs-comment"># https://nim-lang.org/docs/monotimes.html#getMonoTime</span>
      code
      <span class="hljs-keyword">let</span> √©coul√© = getMonoTime() - t0
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;CPU Time [&quot;</span>, nomBenchmark, <span class="hljs-string">&quot;] &quot;</span>, √©coul√©

  benchmark <span class="hljs-string">&quot;test1&quot;</span>: <span class="hljs-comment"># Devrait retourner une valeur proche de 100 ms</span>
    sleep(<span class="hljs-number">100</span>)

nbText:<span class="hljs-string">&quot;&quot;&quot;
Le code qui est indent√© en-dessous du bloc `benchmark` sera d√©limit√© par le code du benchmark.

Puisque la substitution du code est r√©alis√©e au moment de la compilation, cette transformation ne modifie pas les temps obtenus.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Exercice:
  Modifier le code pr√©c√©dent pour effectuer une moyenne des temps obtenus apr√®s autant de r√©p√©titions que demander par l'utilisateur.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Macros&quot;</span>
nbText:<span class="hljs-string">&quot;&quot;&quot;
Les Templates utilisent les param√®tres `untyped` comme des briques de LEGO¬©, c'est-√†-dire comme du code indivisible qui ne peut-√™tre inspect√© pour ses propri√©t√©s.
Si par exemple, nous ne voulions pas que l'utilisateur de notre template passe en argument un code contenant des d√©clarations, nous ne pourrions le v√©rifier avec un template.
L'utilisateur obtiendrait alors une erreur due √† son mauvais usage de la fonction sans que nous puissions faire quelque chose pour l'en emp√™cher.

Les `macro`s sont en quelque sorte des `template` am√©lior√©es qui peuvent analyser le code qu'elles re√ßoivent en argument.

¬´ Tandis que les templates remplacent du code, les macros r√©alisent une introspection. ¬ª

Ici, une introspection de code signifie en analyser le contenu: pr√©sence de d√©finitions, analyser les types utilis√©s, etc‚Ä¶

Au-del√†, de l'introspection, les `macro`s vont pouvoir retourner une version modifi√©e du code pass√© en argument en injectant des variables dans le code original.

En premier exemple de `macro`, j'ai choisi la macro la plus simple possible puisqu'elle ne retourne rien, ou plus pr√©cis√©ment, une liste vide d'instructions.
Le code qui lui est pass√© en argument provoquerait une boucle infinie si ex√©cut√©. Heureusement, le code g√©n√©r√© par la macro √©tant vide, rien n'est ex√©cut√©.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">macro</span> jetteAuxOubliettes(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-literal">result</span> = newStmtList()

  jetteAuxOubliettes:
    <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>:
      <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Si tu ne fais rien, je te spammerai ind√©finiment !&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
### Arbre syntaxique abstrait

Un arbre syntaxique (abstrait) (en anglais AST pour &quot;abstract syntaxic tree&quot;) est une repr√©sentation du code interne au compilateur, qui est dite interm√©diaire, car elle repr√©sente le code entre le code source (compr√©hensible par un humain) et le code g√©n√©r√© (difficilement compr√©hensible par un humain mais pour un compilateur: code C, C++, Objective-C, ou Javascript selon le `backend`).

Chaque code source Nim a son √©quivalent en AST. En revanche plusieurs codes sources peuvent correspondre √† un AST.

Les commentaires et espaces du code source sont supprim√©s.

L'arbre syntaxique repr√©sente le code source sous la forme d'une arborescence ordonn√©e. L'AST est form√©e de n≈ìuds qui poss√®dent chacun un ou plusieurs n≈ìuds enfants. Ces n≈ìuds ne peuvent √™tre intervertis sans changer le sens du code.

Pour obtenir une repr√©sentation du code syntaxique d'un code, on peut √©crire ce code sous une `macro` sp√©ciale appel√©e `dumpTree`.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
### AST Manipulation
In Nim, the code is read and transformed in an internal intermediate representation called an Abstract Syntax Tree (AST). To get a representation of the AST corresponding to a code, we can use the `macro` `dumpTree`.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-comment"># N'oubliez pas d'importer std/macros!</span>
  <span class="hljs-comment"># Vous pouvez utiliser --hints:off pour mieux discerner l'Arbre syntaxique</span>
  dumpTree:
    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Salut!&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Vous trouverez dans la sortie du compilateur l'AST suivant:
```nim
StmtList
  Command
    Ident &quot;echo&quot;
    StrLit &quot;Salut!&quot;
```
Ce code contient quatre n≈ìuds. `StmtList` est √† la racine de l'arbre, puis chaque indentation d√©signe que l'on passe √† un n≈ìud enfant, √† un niveau inf√©rieur dans la hi√©rarchie.

`StmtList` est la contraction de _statements list_ qui signifie bloc d'instructions. Il rassemble ensemble toutes les instructions dans le bloc.

Le n≈ìud suivant `Command` indique que l'on utilise une proc√©dure dont le nom est donn√© par son n≈ìud enfant `Ident`. Un `Ident` peut-√™tre le nom d'une variable, d'un objet ou d'une proc√©dure.
Le n≈ìud `Command` pr√©cise la fa√ßon dont la proc√©dure est appel√©e. Je ne d√©taille pas ici, mais cela a un rapport avec l'UFCS: Uniform Function Call Syntax qui est une propri√©t√© du langage qui indique qu'une fonction ou proc√©dure peut √™tre appel√©e indiff√©remment avec trois syntaxes distinctes.

Nous avons ensuite deux n≈ìuds avec du texte accol√© √† la suite. Les n≈ìuds correspondants √† des noms de variables ou de proc√©dures sont des n≈ìuds de type `Ident`.
Les chaines de caract√®res sont des n≈ìuds de type `StrLit`.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Afin de vous donner une id√©e de ce qui se passe en g√©n√©ral, voici un exemple d'un code nettement plus complexe.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-comment"># Don't forget to import std/macros!</span>
  <span class="hljs-comment"># You can use --hints:off to display only the AST tree</span>
  dumpTree:
    <span class="hljs-keyword">type</span>
      myObject {.packed.} = <span class="hljs-keyword">ref</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        left: <span class="hljs-built_in">seq</span>[myObject]
        right: <span class="hljs-built_in">seq</span>[myObject]

nbText:<span class="hljs-string">&quot;&quot;&quot;
Ce code donne en sortie l'arbre syntaxique suivant:
```nim
StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;myObject&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      RefTy
        ObjectTy
          Empty
          OfInherit
            Ident &quot;RootObj&quot;
          RecList
            IdentDefs
              Ident &quot;left&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
            IdentDefs
              Ident &quot;right&quot;
              BracketExpr
                Ident &quot;seq&quot;
                Ident &quot;myObject&quot;
              Empty
```
L'AST retourn√© par `dumpTree` d√©marrera sauf quelques exceptions toujours par `StmtList`.
Les d√©finitions de type se retrouvent toujours dans une `TypeSection` qui poss√®dent autant d'enfants de type `TypeDef` que de d√©finitions.
Les types objets sont d√©finis par des `ObjectTy`.

Afin de mieux visualiser l'hi√©rarchie, vous trouverez ci-dessous un sch√©ma de l'AST:
&quot;&quot;&quot;</span>

nbImage(url=<span class="hljs-string">&quot;pictures/ASTtree.jpg&quot;</span>, caption=<span class="hljs-string">&quot;Arbre syntaxique de la d√©finition du type myObject&quot;</span>)

nbText:<span class="hljs-string">&quot;&quot;&quot;
Il n'est pas n√©cessaire que vous compreniez l'ensemble de la g√©n√©ration de l'AST. Sachez simplement que vous pouvez l'obtenir avec la commande `DumpTree`.
Si jamais vous avez besoin d'√©crire vous m√™me un AST pour une macro, sachez que des exemples pour toutes les structures et mots-clefs sont dans la documentation des macros:
[std/macros](https://nim-lang.org/docs/macros.html)
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
### Premier exemple de Macro: multiplication par deux
La premi√®re macro que je vous pr√©sente provient de cette [vid√©o Youtube](https://www.youtube.com/watch?v=WHyOHQ_GkNo) r√©alis√©e par [Jeff Delaunay sur sa cha√Æne Fireship](https://www.youtube.com/c/Fireship).

Lorsque un utilisateur d√©sire afficher des valeurs enti√®res sous cette macro, les valeurs seront multipli√©es par deux.
&quot;&quot;&quot;</span>

nbCode:
  <span class="hljs-keyword">macro</span> timesTwo(statements: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-literal">result</span> = statements
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> <span class="hljs-literal">result</span>:
      <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> s:
        <span class="hljs-keyword">if</span> node.kind == nnkIntLit:
          node.intVal = node.intVal*<span class="hljs-number">2</span>
  timesTwo:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Avant d'expliciter le fonctionnement de la macro, on va comparer l'AST du code donn√© en entr√©e,
avec celui que l'on pense obtenir avec le code:
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">3</span>
  dumpTree:
    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">4</span>
    <span class="hljs-keyword">echo</span> <span class="hljs-number">6</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Le compilateur retourne:
```nim
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 3
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
```
Cette sortie ressemble √† s'y m√©prendre au premier exemple d'AST vu pr√©c√©demment.
Au lieu du StrLit &quot;Salut!&quot;, on a d√©sormais IntLit suivi du nombre pr√©sent dans le code source ou dans la sortie.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
En compilant ce code, vous obtiendrez l‚ÄôAST correspondant. Cet AST simple est compos√© de quatre n≈ìuds :

```nim
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 1
```

`StmtList` signifie *liste d‚Äôinstructions*. Il regroupe toutes les instructions de votre bloc.

Le n≈ìud `Command` indique que vous utilisez une fonction dont le nom est donn√© par son n≈ìud enfant `Ident`. Un `Ident` peut √™tre n‚Äôimporte quel nom de variable, d‚Äôobjet ou de proc√©dure.

Notre litt√©ral entier dont la valeur est 1 poss√®de le type de n≈ìud `IntLit`.

Remarquez que l‚Äôordre des n≈ìuds dans l‚ÄôAST est crucial. Si nous inversons les deux derniers n≈ìuds, nous obtiendrions l‚ÄôAST du code `1 echo`, qui ne compile pas.

```nim
StmtList
  Command
    IntLit 1
    Ident &quot;echo&quot;
```

`StmtList`, `Command`, `IntLit` et `Ident` sont les NodeKind de l‚ÄôAST du code. √Ä l‚Äôint√©rieur d‚Äôune macro, ils sont nomm√©s avec le pr√©fixe `nnk`, par exemple : `nnkIdent`.

Vous pouvez obtenir la liste compl√®te des node kinds dans le [code source de std/macros](https://github.com/nim-lang/Nim/blob/a8c6e36323601a64dcb6947a694f0bde97b632b2/lib/core/macros.nim#L25-L89).
&quot;&quot;&quot;</span>

<span class="hljs-comment"># Version IA (version traduite)</span>
nbText:<span class="hljs-string">&quot;&quot;&quot;
## Premier exemple de macro

La sortie d‚Äôune macro est un AST. Voici ce qu‚Äôon obtient pour un exemple simple :

```nim
StmtList
  Command
    Ident &quot;echo&quot;
    IntLit 2
  Command
    Ident &quot;echo&quot;
    IntLit 4
  Command
    Ident &quot;echo&quot;
    IntLit 6
```

Les retours √† la ligne ne font pas partie de l‚ÄôAST !

Ici, l‚ÄôAST de sortie est presque identique √† l‚Äôentr√©e. Seule la valeur des litt√©raux entiers change.

Le n≈ìud racine est une liste d‚Äôinstructions. Pour acc√©der √† ses √©l√©ments, on utilise l‚Äôindexation : `statements[0]`.

Pour parcourir tous ses enfants : `for statement in statements`.

Nous devons r√©cup√©rer les n≈ìuds situ√©s sous une instruction `Command` qui sont des litt√©raux entiers, puis modifier `node.intVal`.
&quot;&quot;&quot;</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
## Analyse d‚Äôune d√©finition de type

Nous voulons afficher la repr√©sentation m√©moire d‚Äôun type donn√©. L‚Äôobjectif est de rep√©rer des champs mal align√©s qui cr√©ent des &quot;trous&quot; de m√©moire (padding) dans les objets.

Les processeurs pr√©f√®rent que les adresses soient align√©es sur des puissances de deux. Sinon, ils ins√®rent du padding.

On peut compacter les structures avec `{.packed.}`, mais cela ralentit les acc√®s m√©moire.

La premi√®re √©tape consiste √† observer l‚ÄôAST d‚Äôune d√©finition de type simple.

### Exemple minimal
&quot;&quot;&quot;</span>
nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span>
        a: <span class="hljs-built_in">float32</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
R√©sultat :

```nim
StmtList
  TypeSection
    TypeDef
      Ident &quot;Thing&quot;
      Empty
      ObjectTy
        Empty
        Empty
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
```

Nous augmenterons la complexit√© pour rep√©rer les cas particuliers.
## Exemple avec h√©ritage et pragmas
&quot;&quot;&quot;</span>

nbCode:
  dumpTree:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> {.packed.} = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        a: <span class="hljs-built_in">float32</span>
        b: <span class="hljs-built_in">string</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
AST :

```nim
StmtList
  TypeSection
    TypeDef
      PragmaExpr
        Ident &quot;Thing&quot;
        Pragma
          Ident &quot;packed&quot;
      Empty
      ObjectTy
        Empty
        OfInherit
          Ident &quot;RootObj&quot;
        RecList
          IdentDefs
            Ident &quot;a&quot;
            Ident &quot;float32&quot;
            Empty
          IdentDefs
            Ident &quot;b&quot;
            Ident &quot;string&quot;
            Empty
```

Notez que le nom du type appara√Æt sous `PragmaExpr`. Il faudra en tenir compte lors de la lecture de l'arbre que nous allons devoir r√©aliser pour la macro.

## Structure g√©n√©rale d‚Äôune macro

Une macro suit toujours les m√™mes √©tapes :

1. Chercher un n≈ìud d‚Äôun type particulier dans l‚ÄôAST.
2. Extraire ses propri√©t√©s.
3. G√©n√©rer un AST en sortie bas√© sur ces propri√©t√©s.
4. Continuer √† parcourir l‚ÄôAST.

Vos macros auront besoin de commentaires d√©taill√©s pour rester lisibles.

## Macro `typeMemoryRepr`

Cette macro g√©n√®re automatiquement :

* la d√©claration du type,
* une variable d‚Äôexemple,
* l‚Äôaffichage de sa taille et adresse,
* l‚Äôaffichage de la taille et adresse de chaque champ.

Cela √©vite d‚Äô√©crire manuellement des dizaines de `echo var.field.sizeof`.

### Construction de fragments AST

#### Affichage de la taille d‚Äôun champ
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> echoSizeVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
    <span class="hljs-comment">## quote do:</span>
    <span class="hljs-comment">##   echo `variable`.`nameOfField`.sizeof</span>
    newStmtList(nnkCommand.newTree(
              newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
              nnkDotExpr.newTree(
                nnkDotExpr.newTree(
                  newIdentNode(variable),
                  newIdentNode(nameOfField) <span class="hljs-comment"># Nom du champ</span>
                  ),
                  newIdentNode(<span class="hljs-string">&quot;sizeof&quot;</span>)
              )
              ))

nbText:<span class="hljs-string">&quot;&quot;&quot;
#### Affichage de l‚Äôadresse d‚Äôun champ
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">proc</span> echoAddressVarFieldStmt(variable: <span class="hljs-built_in">string</span>, nameOfField: <span class="hljs-built_in">string</span>): <span class="hljs-type">NimNode</span> =
    <span class="hljs-comment">## quote do:</span>
    <span class="hljs-comment">##   echo `variable`.`nameOfField`.addr.repr</span>
    newStmtList(nnkCommand.newTree(
                newIdentNode(<span class="hljs-string">&quot;echo&quot;</span>),
                nnkDotExpr.newTree(
                  nnkDotExpr.newTree(
                    nnkDotExpr.newTree(
                      newIdentNode(variable),
                      newIdentNode(nameOfField)
                    ),
                    newIdentNode(<span class="hljs-string">&quot;addr&quot;</span>)
                  ),
                  newIdentNode(<span class="hljs-string">&quot;repr&quot;</span>)
                )
                ))

nbText:<span class="hljs-string">&quot;&quot;&quot;
### Macro compl√®te
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">macro</span> typeMemoryRepr(typedef: <span class="hljs-built_in">untyped</span>): <span class="hljs-built_in">untyped</span> =
    <span class="hljs-comment">## Cette macro :</span>
    <span class="hljs-comment">## * d√©finit le type</span>
    <span class="hljs-comment">## * cr√©e une variable de ce type</span>
    <span class="hljs-comment">## * affiche sa taille et son adresse</span>
    <span class="hljs-comment">## * affiche la taille et l'adresse de chaque champ</span>

    <span class="hljs-literal">result</span> = quote <span class="hljs-keyword">do</span>:
      `typedef`

    <span class="hljs-keyword">for</span> statement <span class="hljs-keyword">in</span> typedef:
      <span class="hljs-keyword">if</span> statement.kind == nnkTypeSection:
        <span class="hljs-keyword">let</span> typeSection = statement
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; typeSection.len:
          <span class="hljs-keyword">if</span> typeSection[i].kind == nnkTypeDef:
            <span class="hljs-keyword">var</span> tnode = typeSection[i]
            <span class="hljs-keyword">let</span> nameOfType = typeSection[i].findChild(it.kind == nnkIdent)

            <span class="hljs-keyword">let</span> nameOfTestVariable = <span class="hljs-string">&quot;my&quot;</span> &amp; nameOfType.strVal.capitalizeAscii() &amp; <span class="hljs-string">&quot;Var&quot;</span>
            <span class="hljs-keyword">let</span> testVariable = newIdentNode(nameOfTestVariable)

            <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(
              quote <span class="hljs-keyword">do</span>:
                <span class="hljs-keyword">var</span> `testVariable`:`nameOfType`
                <span class="hljs-keyword">echo</span> `testVariable`.sizeof
                <span class="hljs-keyword">echo</span> `testVariable`.<span class="hljs-keyword">addr</span>.repr
            )

            tnode = tnode[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]
            <span class="hljs-keyword">assert</span> tnode.kind == nnkRecList

            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; tnode.len:
              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoSizeVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))
              <span class="hljs-literal">result</span> = <span class="hljs-literal">result</span>.add(echoAddressVarFieldStmt(nameOfTestVariable, tnode[i][<span class="hljs-number">0</span>].strVal))

    <span class="hljs-keyword">echo</span> <span class="hljs-literal">result</span>.repr


nbSection <span class="hljs-string">&quot;Exemple d‚Äôutilisation&quot;</span>

nbCode:
  typeMemoryRepr:
    <span class="hljs-keyword">type</span>
      <span class="hljs-type">Thing</span> = <span class="hljs-keyword">object</span> <span class="hljs-keyword">of</span> <span class="hljs-type">RootObj</span>
        a: <span class="hljs-built_in">float32</span>
        b: <span class="hljs-built_in">string</span>

nbText:<span class="hljs-string">&quot;&quot;&quot;
Analyser un type soi-m√™me est risqu√© : pragmas, h√©ritages, enums, alias, types cycliques, objets `case`, etc.
Une fonction d√©di√©e sera pr√©sent√©e dans une future version.
&quot;&quot;&quot;</span>

nbSection <span class="hljs-string">&quot;Autre macro : `power2Enum`&quot;</span>
nbText:<span class="hljs-string">&quot;&quot;&quot;
Cette macro cr√©e automatiquement des enums dont les valeurs sont des puissances de deux.

```nim
macro power2Enum(body: untyped): untyped =
  let srcFields = body[^1][1..^1]
  var dstFields =  nnkEnumTy.newTree(newEmptyNode())
  for idx, field in enumerate(srcFields):
    dstFields.add nnkEnumFieldDef.newTree(field, newIntLitNode(pow(2.0, idx.float).int))

  body[^1] = dstFields
  echo repr body
  body
```

Usage :

```nim
type Test {.power2Enum.}  = enum
  a, b, c, d
```

Mais souvent, un simple `set` + `cast` suffit.
&quot;&quot;&quot;</span>


nbSection <span class="hljs-string">&quot;R√©f√©rences et bibliographie&quot;</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
Pressez `Ctrl` en m√™me temps que `Clic` pour ouvrir les liens dans un nouvel onglet.

D'abord, quatre ressources officielles du site Nim :

 1. [Nim by Example](https://nim-by-example.github.io/macros/)
 2. [Nim Tutorial (Part III)](https://nim-lang.org/docs/tut3.html)
 3. [Section du manuel sur les macros](https://nim-lang.org/docs/manual.html#macros)
 4. [Documentation standard de std/macros](https://nim-lang.org/docs/macros.html)

Les documents 2 et 3 sont compl√©mentaires, tandis que le dernier sera votre r√©f√©rence exhaustive √† jour. Il fournit des AST pour tous les n≈ìuds.

De nombreux d√©veloppeurs ont √©crit des tutoriels sur les macros :
  1. [Nim in Y minutes](https://learnxinyminutes.com/docs/nim/)
  2. [Jason Beetham a.k.a ElegantBeef's dev.to tutorial](https://dev.to/beef331/demystification-of-macros-in-nim-13n8). This tutorial contains a lot of good first examples.
  3. [Pattern matching (sadly outdated) in macros by DevOnDuty](https://www.youtube.com/watch?v=GJpn6SfR_1M)
  4. [Tomohiro's FAQ section about macros](https://internet-of-tomohiro.netlify.app/nim/faq.en.html#macro)
  5. [The Making of NimYAML's article of flyx](https://flyx.org/nimyaml-making-of/)

Il existe √©galement beaucoup de posts sur le forum qui sont informatifs:
  1. [What is &quot;Metaprogramming&quot; paradigm used for ?](https://forum.nim-lang.org/t/2587)
  2. [Custom macro inserts macro help](https://forum.nim-lang.org/t/9470)
  3. [See generated code after template processing](https://forum.nim-lang.org/t/9498)
  4. [Fast array assignment](https://forum.nim-lang.org/t/10037)
  5. [Variable injection](https://forum.nim-lang.org/t/10513)
  6. [Proc inspection](https://forum.nim-lang.org/t/9127)
  7. etc ‚Ä¶ Utiliser la barre de recherche du forum ! mots-cl√©s: `macro`, `metaprogramming`, `generics`, `template`, ‚Ä¶

Enfin, trois livres Nim :
  1. [Nim In Action, ed. Manning](https://book.picheta.me) and [github repo](https://github.com/dom96/nim-in-action-code)
  2. [Mastering Nim, auto-published by A. Rumpf/Araq, Nim's creator](https://www.amazon.fr/dp/B0B4R7B9YX).
  3. [Nim Programming Book, by S.Salewski](https://ssalewski.de/nimprogramming.html#_macros_and_meta_programming)

De nombreux projets utilisent intensivement des macros ou des templates :
  1. [genny](https://github.com/treeform/genny) and [benchy](https://github.com/treeform/genny). Benchy is a template based library that benchmarks your code snippet under bench blocks. Genny is used to export a Nim library to other languages (C, C++, Node, Python, Zig).
  In general, treeform projects source code are good Nim references
  2. Mon DSL favori : the [neural network domain specific language (DSL) of the tensor library Arraymancer](https://github.com/mratsim/Arraymancer/blob/68786e147a94069a96f069bab327d67afdaa5a3e/src/arraymancer/nn/nn_dsl.nim)
  [mratsim](https://github.com/mratsim/) develops this library, and made [a list of all his DSL](https://forum.nim-lang.org/t/9551#62851) in the forum.
  3. [Jester](https://github.com/dom96/jester) library is a HTML DSL, where each block defines a route in your web application.
  4. [nimib](https://pietroppeter.github.io/nimib/) with which this blog post has been written.
  5. [Nim4UE](https://github.com/jmgomez/NimForUE). You can develop Nim code for the Unreal Engine 5 game engine. The macro system parses your procs and outputs DLL for UE.
&quot;&quot;&quot;</span>
nbSave

<span class="hljs-comment"># nbCode:</span>
<span class="hljs-comment">#   macro timesTwoAndEcho(statements: untyped): untyped =</span>
<span class="hljs-comment">#     result = statements</span>
<span class="hljs-comment">#     for s in result:</span>
<span class="hljs-comment">#       for node in s:</span>
<span class="hljs-comment">#         if node.kind == nnkIntLit:</span>
<span class="hljs-comment">#           node.intVal = node.intVal*2</span>
<span class="hljs-comment">#     echo repr result</span>

<span class="hljs-comment">#   timesTwoAndEcho:</span>
<span class="hljs-comment">#     echo 1</span>
<span class="hljs-comment">#     echo 2</span>
<span class="hljs-comment">#     echo 3</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># The output of a macro is an AST, and we can try to write it for a few examples:</span>
<span class="hljs-comment"># ```nim</span>
<span class="hljs-comment"># StmtList</span>
<span class="hljs-comment">#   Command</span>
<span class="hljs-comment">#     Ident &quot;echo&quot;</span>
<span class="hljs-comment">#     IntLit 2</span>
<span class="hljs-comment">#   Command</span>
<span class="hljs-comment">#     Ident &quot;echo&quot;</span>
<span class="hljs-comment">#     IntLit 4</span>
<span class="hljs-comment">#   Command</span>
<span class="hljs-comment">#     Ident &quot;echo&quot;</span>
<span class="hljs-comment">#     IntLit 6</span>
<span class="hljs-comment"># ```</span>
<span class="hljs-comment"># Please note that line breaks are not part of the Nim's AST!</span>

<span class="hljs-comment"># Here, the output AST is almost the same as the input. We only change the integer literal value.</span>

<span class="hljs-comment"># Our root node in the input AST is a statement list.</span>
<span class="hljs-comment"># To fetch the `Command` children node, we may use the list syntax.</span>
<span class="hljs-comment"># A Node contains the list of its childrens. To get the first children, it suffices to write `statements[0]`.</span>
<span class="hljs-comment"># To loop over all the child nodes, one can use a `for statement in statements` loop.</span>

<span class="hljs-comment"># We need to fetch the nodes under a `Command` instruction that are integer literals.</span>
<span class="hljs-comment"># So for each node in the statement, we test if the node kind is equal to `nnkIntLit`. We get their value with the attribute `node.intVal`.</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>


<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># I present down my first macro as an example.</span>
<span class="hljs-comment"># I want to print the memory layout of a given type.</span>
<span class="hljs-comment"># My goal is to find misaligned fields making useless unocuppied memory in a type object definition.</span>
<span class="hljs-comment"># This happens when the attributes have types of different sizes. The order of the attributes then changes the memory used by an object.</span>
<span class="hljs-comment"># To deal with important chunks of memory, the processor stores an object and its attributes with [some rules](https://en.wikipedia.org/wiki/Data_structure_alignment).</span>

<span class="hljs-comment"># It likes when adresses are separated by powers of two. If it is not, it inserts a padding (unoccupied memory) between two attributes.</span>

<span class="hljs-comment"># We can pack a structure with the pragma `{.packed.}`, which removes this extra space. This has the disadvantage to slow down memory accesses.</span>

<span class="hljs-comment"># We would like to detect the presence of holes in an object.</span>

<span class="hljs-comment"># The first step is to look at the AST of the input code we want to parse.</span>

<span class="hljs-comment"># One can look first at the most basic type definition possible, before trying to complexify the AST to get a feel of all the edge cases.</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbCode:</span>
<span class="hljs-comment">#   dumpTree:</span>
<span class="hljs-comment">#     type</span>
<span class="hljs-comment">#       Thing = object</span>
<span class="hljs-comment">#         a: float32</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># ```nim</span>
<span class="hljs-comment"># StmtList</span>
<span class="hljs-comment">#   TypeSection</span>
<span class="hljs-comment">#     TypeDef</span>
<span class="hljs-comment">#       Ident &quot;Thing&quot;</span>
<span class="hljs-comment">#       Empty</span>
<span class="hljs-comment">#       ObjectTy</span>
<span class="hljs-comment">#         Empty</span>
<span class="hljs-comment">#         Empty</span>
<span class="hljs-comment">#         RecList</span>
<span class="hljs-comment">#           IdentDefs</span>
<span class="hljs-comment">#             Ident &quot;a&quot;</span>
<span class="hljs-comment">#             Ident &quot;float32&quot;</span>
<span class="hljs-comment">#             Empty</span>
<span class="hljs-comment"># ```</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>

<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># We have to get outputs as much complex as possible to detect edge cases, while keeping the information to the minimum to easily read the AST and locate errors.</span>
<span class="hljs-comment"># I present here first some samples of type definition on which I will run my macro.</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbText:hlMd&quot;&quot;&quot;</span>
<span class="hljs-comment"># ```nim</span>
<span class="hljs-comment"># typeMemoryRepr:</span>
<span class="hljs-comment">#   type</span>
<span class="hljs-comment">#     Thing2 = object</span>
<span class="hljs-comment">#       oneChar: char</span>
<span class="hljs-comment">#       myStr: string</span>
<span class="hljs-comment">#   type</span>
<span class="hljs-comment">#     Thing = object of RootObj</span>
<span class="hljs-comment">#       a: float32</span>
<span class="hljs-comment">#       b: uint64</span>
<span class="hljs-comment">#       c: char</span>
<span class="hljs-comment"># ```</span>

<span class="hljs-comment"># Type with pragmas aren't supported yet</span>
<span class="hljs-comment"># ```nim</span>


<span class="hljs-comment"># when false: # erroneous code</span>

<span class="hljs-comment">#   typeMemoryRepr:</span>
<span class="hljs-comment">#     type</span>
<span class="hljs-comment">#       Thing {.packed.} = object</span>
<span class="hljs-comment">#         oneChar: char</span>
<span class="hljs-comment">#         myStr: string</span>
<span class="hljs-comment"># ```</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># It is not easy (if even possible) to list all possible types.</span>
<span class="hljs-comment"># Yet by adding some other informations we can get a better picture of the general AST of a type.</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbCode:</span>
<span class="hljs-comment">#   dumpTree:</span>
<span class="hljs-comment">#     type</span>
<span class="hljs-comment">#       Thing {.packed.} = object of RootObj</span>
<span class="hljs-comment">#         a: float32</span>
<span class="hljs-comment">#         b: string</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># ```nim</span>
<span class="hljs-comment"># StmtList</span>
<span class="hljs-comment">#   TypeSection</span>
<span class="hljs-comment">#     TypeDef</span>
<span class="hljs-comment">#       PragmaExpr</span>
<span class="hljs-comment">#         Ident &quot;Thing&quot;</span>
<span class="hljs-comment">#         Pragma</span>
<span class="hljs-comment">#           Ident &quot;packed&quot;</span>
<span class="hljs-comment">#       Empty</span>
<span class="hljs-comment">#       ObjectTy</span>
<span class="hljs-comment">#         Empty</span>
<span class="hljs-comment">#         OfInherit</span>
<span class="hljs-comment">#           Ident &quot;RootObj&quot;</span>
<span class="hljs-comment">#         RecList</span>
<span class="hljs-comment">#           IdentDefs</span>
<span class="hljs-comment">#             Ident &quot;a&quot;</span>
<span class="hljs-comment">#             Ident &quot;float32&quot;</span>
<span class="hljs-comment">#             Empty</span>
<span class="hljs-comment">#           IdentDefs</span>
<span class="hljs-comment">#             Ident &quot;b&quot;</span>
<span class="hljs-comment">#             Ident &quot;string&quot;</span>
<span class="hljs-comment">#             Empty</span>
<span class="hljs-comment"># ```</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># Notice how the name of the type went under the PragmaExpr section. We have to be careful about this when trying to parse the type.</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># A macro does always the same steps:</span>

<span class="hljs-comment">#   1. Search for a node of a specific kind, inside the input AST or check that the given node is of the expected kind.</span>
<span class="hljs-comment">#   2. Fetch properties of the selected node.</span>
<span class="hljs-comment">#   3. Form AST output in function of these input node's properties.</span>
<span class="hljs-comment">#   4. Continue exploring the AST.</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># Your macros will require a long docstring and many comments both with thorough details.</span>

<span class="hljs-comment"># I present now my macro `typeMemoryRepr` inspired from the [nim memory guide](https://zevv.nl/nim-memory/) on memory representation.</span>
<span class="hljs-comment"># In this guide, we manually print types fields address, to get an idea of the memory layout and the space taken by each variable and its fields.</span>

<span class="hljs-comment"># ```nim</span>
<span class="hljs-comment"># type Thing = object</span>
<span class="hljs-comment">#   a: uint32</span>
<span class="hljs-comment">#   b: uint8</span>
<span class="hljs-comment">#   c: uint16</span>

<span class="hljs-comment"># var t: Thing</span>

<span class="hljs-comment"># echo &quot;size t.a &quot;, t.a.sizeof</span>
<span class="hljs-comment"># echo &quot;size t.b &quot;, t.b.sizeof</span>
<span class="hljs-comment"># echo &quot;size t.c &quot;, t.c.sizeof</span>
<span class="hljs-comment"># echo &quot;size t   &quot;, t.sizeof</span>

<span class="hljs-comment"># echo &quot;addr t.a &quot;, t.a.addr.repr</span>
<span class="hljs-comment"># echo &quot;addr t.b &quot;, t.b.addr.repr</span>
<span class="hljs-comment"># echo &quot;addr t.c &quot;, t.c.addr.repr</span>
<span class="hljs-comment"># echo &quot;addr t   &quot;, t.addr.repr</span>
<span class="hljs-comment"># ```</span>

<span class="hljs-comment"># All these echo's are redundant and have to be changed each time we change the type field. For types with more than four or five fields, this becomes not manageable.</span>

<span class="hljs-comment"># I have split this macro into different procedures.</span>
<span class="hljs-comment"># The `echoSizeVarFieldStmt` will take the name of a variable, let us say `a` and of its field `field` and return the code:</span>
<span class="hljs-comment"># ```nim</span>
<span class="hljs-comment"># echo a.field.sizeof</span>
<span class="hljs-comment"># ```</span>
<span class="hljs-comment"># We create a NimNode of kind `StmtList` (a statement list), that contains `IdentNode`s.</span>
<span class="hljs-comment"># The first `IdentNode` is the command `echo`.</span>
<span class="hljs-comment"># We do not represent spaces in the AST. Each term separated by a dot is an Ident and part of a `nnkDotExpr`.</span>

<span class="hljs-comment"># It suffices to output the above code under a `dumpTree` block, to understand the AST we have to generate.</span>
<span class="hljs-comment"># ```nim</span>
<span class="hljs-comment"># dumpTree:</span>
<span class="hljs-comment">#   echo a.field.sizeof</span>
<span class="hljs-comment"># ```</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbCode:</span>
<span class="hljs-comment">#   proc echoSizeVarFieldStmt(variable: string, nameOfField: string): NimNode =</span>
<span class="hljs-comment">#     ## quote do:</span>
<span class="hljs-comment">#     ##   echo `variable`.`nameOfField`.sizeof</span>
<span class="hljs-comment">#     newStmtList(nnkCommand.newTree(</span>
<span class="hljs-comment">#               newIdentNode(&quot;echo&quot;),</span>
<span class="hljs-comment">#               nnkDotExpr.newTree(</span>
<span class="hljs-comment">#                 nnkDotExpr.newTree(</span>
<span class="hljs-comment">#                   newIdentNode(variable),</span>
<span class="hljs-comment">#                   newIdentNode(nameOfField) # The name of the field is the first ident</span>
<span class="hljs-comment">#                   ),</span>
<span class="hljs-comment">#                   newIdentNode(&quot;sizeof&quot;)</span>
<span class="hljs-comment">#               )</span>
<span class="hljs-comment">#               ))</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># The `echoAddressVarFieldStmt` will take the name of a variable, let us say `a` and of its field `field` and return its address:</span>
<span class="hljs-comment"># ```nim</span>
<span class="hljs-comment"># echo a.field.addr.repr</span>
<span class="hljs-comment"># ```</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbCode:</span>
<span class="hljs-comment">#   proc echoAddressVarFieldStmt(variable: string, nameOfField: string): NimNode =</span>
<span class="hljs-comment">#     ## quote do:</span>
<span class="hljs-comment">#     ##   echo `variable`.`nameOfField`.addr.repr</span>
<span class="hljs-comment">#     newStmtList(nnkCommand.newTree(</span>
<span class="hljs-comment">#                 newIdentNode(&quot;echo&quot;),</span>
<span class="hljs-comment">#                 nnkDotExpr.newTree(</span>
<span class="hljs-comment">#                   nnkDotExpr.newTree(</span>
<span class="hljs-comment">#                     nnkDotExpr.newTree(</span>
<span class="hljs-comment">#                       newIdentNode(variable),</span>
<span class="hljs-comment">#                       newIdentNode(nameOfField)</span>
<span class="hljs-comment">#                     ),</span>
<span class="hljs-comment">#                     newIdentNode(&quot;addr&quot;)</span>
<span class="hljs-comment">#                   ),</span>
<span class="hljs-comment">#                   newIdentNode(&quot;repr&quot;)</span>
<span class="hljs-comment">#                 )</span>
<span class="hljs-comment">#                 ))</span>


<span class="hljs-comment"># nbCode:</span>
<span class="hljs-comment">#   macro typeMemoryRepr(typedef: untyped): untyped =</span>
<span class="hljs-comment">#     ## This macro takes a type definition as an argument and:</span>
<span class="hljs-comment">#     ## * defines the type (outputs typedef as is)</span>
<span class="hljs-comment">#     ## * initializes a variable of this type</span>
<span class="hljs-comment">#     ## * echoes the size and address of the variable</span>
<span class="hljs-comment">#     ## Then, for each field:</span>
<span class="hljs-comment">#     ## * echoes the size and address of the variable field</span>

<span class="hljs-comment">#     # We begin by running the type definition.</span>
<span class="hljs-comment">#     result = quote do:</span>
<span class="hljs-comment">#       `typedef`</span>

<span class="hljs-comment">#     # Parse the type definition to find the TypeDef section's node</span>
<span class="hljs-comment">#     # We create the output's AST along parsing.</span>
<span class="hljs-comment">#     # We will receive a statement list as the root of the AST</span>
<span class="hljs-comment">#     for statement in typedef:</span>
<span class="hljs-comment">#       # We select only the type section in the StmtList</span>
<span class="hljs-comment">#       if statement.kind == nnkTypeSection:</span>
<span class="hljs-comment">#         let typeSection = statement</span>
<span class="hljs-comment">#         for i in 0 ..&lt; typeSection.len:</span>
<span class="hljs-comment">#           if typeSection[i].kind == nnkTypeDef:</span>
<span class="hljs-comment">#             var tnode = typeSection[i]</span>
<span class="hljs-comment">#             # The name of the type is the first Ident child. We can get the ident's string with strVal or repr</span>
<span class="hljs-comment">#             let nameOfType = typeSection[i].findChild(it.kind == nnkIdent)</span>

<span class="hljs-comment">#             ## Generation of AST:</span>
<span class="hljs-comment">#             # We create a variable of the given type definition (hopefully not already defined) name for the &quot;myTypenameVar&quot;</span>
<span class="hljs-comment">#             let nameOfTestVariable = &quot;my&quot; &amp; nameOfType.strVal.capitalizeAscii() &amp; &quot;Var&quot;</span>
<span class="hljs-comment">#             let testVariable = newIdentNode(nameOfTestVariable)</span>
<span class="hljs-comment">#             result = result.add(</span>
<span class="hljs-comment">#             quote do:</span>
<span class="hljs-comment">#               var `testVariable`:`nameOfType` # instanciate variable with type defined in typedef</span>
<span class="hljs-comment">#               echo `testVariable`.sizeof # echo the total size</span>
<span class="hljs-comment">#               echo `testVariable`.addr.repr # gives the address in memory</span>
<span class="hljs-comment">#             )</span>
<span class="hljs-comment">#             # myTypeVar.field[i] memory size and address in memory</span>
<span class="hljs-comment">#             tnode = tnode[2][2] # The third child of the third child is the fields's AST</span>
<span class="hljs-comment">#             assert tnode.kind == nnkRecList</span>
<span class="hljs-comment">#             for i in 0 ..&lt; tnode.len:</span>
<span class="hljs-comment">#               # myTypeVar.field[i].sizeof</span>
<span class="hljs-comment">#               result = result.add(echoSizeVarFieldStmt(nameOfTestVariable, tnode[i][0].strVal))</span>
<span class="hljs-comment">#               # myTypeVar.field[i].addr.repr</span>
<span class="hljs-comment">#               result = result.add(echoAddressVarFieldStmt(nameOfTestVariable, tnode[i][0].strVal))</span>

<span class="hljs-comment">#     echo result.repr</span>

<span class="hljs-comment"># nbCode:</span>
<span class="hljs-comment">#   typeMemoryRepr:</span>
<span class="hljs-comment">#     type</span>
<span class="hljs-comment">#       Thing = object of RootObj</span>
<span class="hljs-comment">#         a: float32</span>
<span class="hljs-comment">#         b: string</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># Trying to parse a type ourselve is risky, since there are numerous easily forgettable possibilities (due to pragma expressions, cyclic types, and many kind of types: object, enum, type alias, etc..., case of fields, branching and conditionals inside the object, ‚Ä¶ ).</span>

<span class="hljs-comment"># There is actually already a function to do so and this will be the object of a future release of this tutorial.</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># The following macro enables to create enums with power of two values.</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbCodeSkip:</span>
<span class="hljs-comment">#   import std/[enumerate, math]</span>

<span class="hljs-comment"># nbCode:</span>
<span class="hljs-comment">#   # jmgomez on Discord</span>
<span class="hljs-comment">#   macro power2Enum(body: untyped): untyped =</span>
<span class="hljs-comment">#     let srcFields = body[^1][1..^1]</span>
<span class="hljs-comment">#     var dstFields =  nnkEnumTy.newTree(newEmptyNode())</span>
<span class="hljs-comment">#     for idx, field in enumerate(srcFields):</span>
<span class="hljs-comment">#       dstFields.add nnkEnumFieldDef.newTree(field, newIntLitNode(pow(2.0, idx.float).int))</span>

<span class="hljs-comment">#     body[^1] = dstFields</span>
<span class="hljs-comment">#     echo repr body</span>
<span class="hljs-comment">#     body</span>


<span class="hljs-comment">#   type Test {.power2Enum.}  = enum</span>
<span class="hljs-comment">#     a, b, c, d</span>

<span class="hljs-comment"># nbText:&quot;&quot;&quot;</span>
<span class="hljs-comment"># A macro is not always the best alternative. A simple set and a cast gives the same result.</span>
<span class="hljs-comment"># &quot;&quot;&quot;</span>

<span class="hljs-comment"># nbCode:</span>
<span class="hljs-comment">#   # Rika</span>
<span class="hljs-comment">#   type</span>
<span class="hljs-comment">#     Setting = enum</span>
<span class="hljs-comment">#       a, b, c</span>
<span class="hljs-comment">#     Settings = set[Setting]</span>
<span class="hljs-comment">#   let settings: Settings = {a, c}</span>
<span class="hljs-comment">#   echo cast[uint8](settings)</span>
</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>